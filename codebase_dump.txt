--- VERSION 14 (CODE) START ---

--- Directory Tree Structure ---
Project Root: /home/flore/projects/Connect4
Connect4/
├── backend/
│   ├── app/
│   │   ├── api/
│   │   │   ├── admin.py
│   │   │   ├── stats.py
│   │   │   ├── tournament.py
│   │   │   └── websocket_manager.py
│   │   ├── core/
│   │   │   └── database.py
│   │   ├── engine/
│   │   │   ├── ai.py
│   │   │   ├── elo.py
│   │   │   └── game.py
│   │   ├── models/
│   │   │   ├── elo_model.py
│   │   │   ├── game_model.py
│   │   │   └── tournament_model.py
│   │   ├── schemas/
│   │   │   └── game_schema.py
│   │   ├── services/
│   │   │   ├── __init__.py
│   │   │   ├── game_runner.py
│   │   │   ├── game_service.py
│   │   │   └── tournament_service.py
│   │   └── main.py
│   ├── migrations/
│   ├── scripts/
│   │   ├── cleanup_games.py
│   │   ├── init_db.py
│   │   ├── test_models.py
│   │   └── verify_ai_moves.py
│   ├── Dockerfile
│   ├── migrate_analytics.py
│   └── requirements.txt
├── frontend/
│   ├── public/
│   │   └── vite.svg
│   ├── src/
│   │   ├── api/
│   │   │   └── client.js
│   │   ├── assets/
│   │   │   └── react.svg
│   │   ├── components/
│   │   │   ├── GameBoard.jsx
│   │   │   ├── Layout.jsx
│   │   │   ├── MiniGameBoard.jsx
│   │   │   └── Navigation.jsx
│   │   ├── context/
│   │   │   └── ThemeContext.jsx
│   │   ├── hooks/
│   │   │   └── useGameSocket.js
│   │   ├── pages/
│   │   │   ├── Admin.jsx
│   │   │   ├── Arena.jsx
│   │   │   ├── Dashboard.jsx
│   │   │   ├── History.jsx
│   │   │   ├── NewGame.jsx
│   │   │   ├── Statistics.jsx
│   │   │   └── Tournament.jsx
│   │   ├── App.css
│   │   ├── App.jsx
│   │   ├── index.css
│   │   └── main.jsx
│   ├── .gitignore
│   ├── Dockerfile
│   ├── README.md
│   ├── eslint.config.js
│   ├── index.html
│   ├── package.json
│   ├── postcss.config.js
│   ├── tailwind.config.js
│   └── vite.config.js
├── .gitignore
├── MODELS.md
├── README.md
├── TECHNICAL_SPEC.md
└── docker-compose.yml

--- Tree Summary ---
19 directories, 58 files listed.
Exclusion patterns used: 41


--- File Contents ---


--- File: backend/app/api/admin.py ---
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from backend.app.core.database import get_db

router = APIRouter()

@router.delete("/reset", status_code=status.HTTP_200_OK)
async def reset_database(confirmation: str, db: AsyncSession = Depends(get_db)):
    """
    Resets the database.
    Query Param 'confirmation' must equal 'I-UNDERSTAND-THIS-DELETES-EVERYTHING'.
    """
    if confirmation != "I-UNDERSTAND-THIS-DELETES-EVERYTHING":
        raise HTTPException(
            status_code=400, 
            detail="Invalid confirmation string. Operation aborted."
        )

    try:
        # Truncate tables in specific order to handle foreign keys if they existed
        # Using RESTART IDENTITY to reset ID counters to 1
        await db.execute(text("TRUNCATE TABLE elo_history RESTART IDENTITY CASCADE;"))
        await db.execute(text("TRUNCATE TABLE elo_ratings RESTART IDENTITY CASCADE;"))
        await db.execute(text("TRUNCATE TABLE games RESTART IDENTITY CASCADE;"))
        
        await db.commit()
        return {"message": "Database successfully wiped."}
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/status")
async def get_admin_status(db: AsyncSession = Depends(get_db)):
    """
    Get database statistics for admin dashboard.
    """
    try:
        # Count records in each table
        games_result = await db.execute(text("SELECT COUNT(*) FROM games;"))
        games_count = games_result.scalar()
        
        ratings_result = await db.execute(text("SELECT COUNT(*) FROM elo_ratings;"))
        ratings_count = ratings_result.scalar()
        
        history_result = await db.execute(text("SELECT COUNT(*) FROM elo_history;"))
        history_count = history_result.scalar()
        
        return {
            "games": games_count,
            "elo_ratings": ratings_count, 
            "elo_history": history_count
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
--- End of File: backend/app/api/admin.py ---

--- File: backend/app/api/stats.py ---
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import desc, or_
from typing import List, Dict, Any
from pydantic import BaseModel, ConfigDict
from datetime import datetime

from backend.app.core.database import get_db
from backend.app.models.elo_model import EloRating, EloHistory
from backend.app.models.game_model import Game
from backend.app.engine.ai import MODEL_PROVIDERS

router = APIRouter()

# --- Schemas ---
class LeaderboardEntry(BaseModel):
    model_config = ConfigDict(protected_namespaces=())
    
    model_name: str
    rating: float
    matches_played: int
    wins: int
    losses: int
    draws: int
    
    # --- Expanded Stats ---
    mean_time_per_move: float
    avg_moves_per_game: float
    mean_tokens_out_per_move: float
    total_tokens_out: int
    
    # --- Cost Stats ---
    avg_cost_per_move: float
    avg_cost_per_game: float
    total_cost: float

class HistoryPoint(BaseModel):
    model_config = ConfigDict(protected_namespaces=())
    
    model_name: str
    rating: float
    timestamp: datetime

class LiveGameSummary(BaseModel):
    id: int
    player_1: str
    player_2: str
    move_count: int
    created_at: datetime
    board: List[List[int]] # Added board state (6 rows x 7 cols)

# --- NEW: Matrix Schemas ---
class MatrixCell(BaseModel):
    wins: int
    losses: int
    draws: int
    total: int
    win_rate: float # 0.0 to 100.0

class MatrixResponse(BaseModel):
    models: List[str] # Ordered list of model names (rows/cols)
    grid: Dict[str, Dict[str, MatrixCell]] # grid[row_model][col_model] -> Stats

# --- Endpoints ---

@router.get("/leaderboard", response_model=List[LeaderboardEntry])
async def get_leaderboard(db: AsyncSession = Depends(get_db)):
    """Returns models sorted by ELO rating with detailed stats."""
    result = await db.execute(select(EloRating).order_by(desc(EloRating.rating)))
    ratings = result.scalars().all()
    
    output = []
    for r in ratings:
        # 1. Base Stats
        total_moves = r.total_moves or 0
        matches = r.matches_played or 0
        
        # 2. Averages
        mean_time = (r.total_duration_seconds / total_moves) if total_moves > 0 else 0.0
        mean_tokens_out = (r.total_output_tokens / total_moves) if total_moves > 0 else 0.0
        avg_moves_game = (total_moves / matches) if matches > 0 else 0.0
        
        # 3. Cost Calculations (USD)
        # Pricing is per 1 Million tokens
        pricing = MODEL_PROVIDERS.get(r.model_name, {}).get("pricing", {"input": 0, "output": 0})
        
        cost_input = (r.total_input_tokens or 0) / 1_000_000 * pricing.get("input", 0)
        cost_output = (r.total_output_tokens or 0) / 1_000_000 * pricing.get("output", 0)
        total_cost_usd = cost_input + cost_output
        
        avg_cost_game = (total_cost_usd / matches) if matches > 0 else 0.0
        avg_cost_move = (total_cost_usd / total_moves) if total_moves > 0 else 0.0
        
        output.append(LeaderboardEntry(
            model_name=r.model_name,
            rating=r.rating,
            matches_played=matches,
            wins=r.wins,
            losses=r.losses,
            draws=r.draws,
            
            # Time & Volume
            mean_time_per_move=round(mean_time, 2),
            avg_moves_per_game=round(avg_moves_game, 1),
            mean_tokens_out_per_move=round(mean_tokens_out, 1),
            total_tokens_out=r.total_output_tokens or 0,
            
            # Economics
            avg_cost_per_move=round(avg_cost_move, 5),
            avg_cost_per_game=round(avg_cost_game, 4),
            total_cost=round(total_cost_usd, 4)
        ))
        
    return output

@router.get("/history", response_model=List[HistoryPoint])
async def get_rating_history(model: str = None, db: AsyncSession = Depends(get_db)):
    """Returns time-series data. Optional filter by specific model."""
    query = select(EloHistory).order_by(EloHistory.timestamp)
    if model:
        query = query.where(EloHistory.model_name == model)
    
    result = await db.execute(query)
    return result.scalars().all()

@router.get("/active-games", response_model=List[LiveGameSummary])
async def get_active_games(db: AsyncSession = Depends(get_db)):
    """Returns games currently IN_PROGRESS with reconstructed board state."""
    query = select(Game).where(Game.status == "IN_PROGRESS").order_by(desc(Game.created_at)).limit(20)
    result = await db.execute(query)
    games = result.scalars().all()
    
    summaries = []
    for g in games:
        # Reconstruct board state (6x7)
        # 0=Empty, 1=Player1, 2=Player2
        board = [[0 for _ in range(7)] for _ in range(6)]
        
        if g.history:
            for move in g.history:
                col = move.get('column')
                player = move.get('player')
                
                if col is not None and 0 <= col < 7:
                    # Gravity logic: find lowest empty row
                    for r in range(5, -1, -1):
                        if board[r][col] == 0:
                            board[r][col] = player
                            break

        summaries.append(LiveGameSummary(
            id=g.id,
            player_1=g.player_1_type,
            player_2=g.player_2_type,
            move_count=len(g.history) if g.history else 0,
            created_at=g.created_at,
            board=board
        ))
    
    return summaries

@router.get("/matrix", response_model=MatrixResponse)
async def get_win_rate_matrix(db: AsyncSession = Depends(get_db)):
    """
    Calculates the N x N win rate matrix for all models.
    Aggregates data server-side to prevent frontend heaviness.
    """
    # 1. Get all models sorted by Rating (High to Low)
    # We want the matrix rows/cols to be ordered by skill
    models_result = await db.execute(select(EloRating.model_name).order_by(desc(EloRating.rating)))
    models = models_result.scalars().all()
    
    # 2. Get all completed games
    games_result = await db.execute(
        select(Game.player_1_type, Game.player_2_type, Game.winner)
        .where(Game.status.in_(["COMPLETED", "DRAW"]))
    )
    games = games_result.all()
    
    # 3. Initialize Data Structure
    # stats[model_A][model_B] = {wins, losses, draws}
    stats = {m: {opp: {"w": 0, "l": 0, "d": 0} for opp in models} for m in models}
    
    # 4. Aggregate
    for p1, p2, winner in games:
        # Skip if models were deleted or unknown
        if p1 not in stats or p2 not in stats:
            continue
            
        if winner == 1:
            stats[p1][p2]["w"] += 1
            stats[p2][p1]["l"] += 1
        elif winner == 2:
            stats[p1][p2]["l"] += 1
            stats[p2][p1]["w"] += 1
        else: # Draw
            stats[p1][p2]["d"] += 1
            stats[p2][p1]["d"] += 1
            
    # 5. Format Response
    grid_output = {}
    
    for model_row in models:
        row_data = {}
        for model_col in models:
            if model_row == model_col:
                # Identity cell (vs self) - usually null or specific marker
                row_data[model_col] = MatrixCell(wins=0, losses=0, draws=0, total=0, win_rate=0.0)
                continue
                
            s = stats[model_row][model_col]
            total = s["w"] + s["l"] + s["d"]
            
            # Formula: (Wins + 0.5 * Draws) / Total
            if total > 0:
                score = s["w"] + (0.5 * s["d"])
                win_rate = (score / total) * 100.0
            else:
                win_rate = 0.0
                
            row_data[model_col] = MatrixCell(
                wins=s["w"],
                losses=s["l"],
                draws=s["d"],
                total=total,
                win_rate=round(win_rate, 1)
            )
        grid_output[model_row] = row_data
        
    return MatrixResponse(models=models, grid=grid_output)
--- End of File: backend/app/api/stats.py ---

--- File: backend/app/api/tournament.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from pydantic import BaseModel
from typing import List, Optional

from backend.app.core.database import get_db
from backend.app.services.tournament_service import tournament_service
from backend.app.models.tournament_model import Tournament

router = APIRouter()

class TournamentCreate(BaseModel):
    models: List[str]
    rounds: int = 1
    concurrency: int = 2

@router.post("/create")
async def create_tournament(payload: TournamentCreate, db: AsyncSession = Depends(get_db)):
    t = await tournament_service.create_tournament(
        db, payload.models, payload.rounds, payload.concurrency
    )
    return {"id": t.id, "total_matches": t.total_matches, "status": t.status}

@router.post("/{id}/start")
async def start_tournament(id: int, db: AsyncSession = Depends(get_db)):
    success = await tournament_service.start_tournament(db, id)
    if not success:
        raise HTTPException(status_code=404, detail="Tournament not found")
    return {"message": "Tournament started"}

@router.post("/{id}/stop")
async def stop_tournament(id: int, db: AsyncSession = Depends(get_db)):
    success = await tournament_service.stop_tournament(db, id)
    return {"message": "Tournament stopped"}

@router.get("/current")
async def get_current_status(db: AsyncSession = Depends(get_db)):
    # Get the most recent active or setup tournament
    result = await db.execute(
        select(Tournament).order_by(Tournament.created_at.desc()).limit(1)
    )
    t = result.scalar_one_or_none()
    if not t:
        return None
    
    # Calculate progress
    # We could optimize this with a count query
    from backend.app.models.game_model import Game
    from sqlalchemy import func
    
    completed = await db.execute(
        select(func.count(Game.id)).where(
            Game.tournament_id == t.id, 
            Game.status.in_(["COMPLETED", "DRAW"])
        )
    )
    completed_count = completed.scalar() or 0
    
    return {
        "id": t.id,
        "status": t.status,
        "config": t.config,
        "total": t.total_matches,
        "completed": completed_count
    }

class TournamentConfigUpdate(BaseModel):
    concurrency: int

@router.post("/{id}/pause")
async def pause_tournament(id: int, db: AsyncSession = Depends(get_db)):
    """Pause a tournament - stops all running games but preserves state."""
    success = await tournament_service.pause_tournament(db, id)
    if not success:
        raise HTTPException(status_code=404, detail="Tournament not found")
    return {"message": "Tournament paused"}

@router.post("/{id}/resume")
async def resume_tournament(id: int, db: AsyncSession = Depends(get_db)):
    """Resume a paused tournament."""
    result = await db.execute(select(Tournament).where(Tournament.id == id))
    t = result.scalar_one_or_none()
    if not t:
        raise HTTPException(status_code=404, detail="Tournament not found")
    
    if t.status != "PAUSED":
        raise HTTPException(status_code=400, detail="Tournament is not paused")
    
    t.status = "IN_PROGRESS"
    await db.commit()
    
    # Trigger tick to resume games
    await tournament_service.tick(db)
    
    return {"message": "Tournament resumed"}

@router.patch("/{id}/config")
async def update_tournament_config(
    id: int, 
    payload: TournamentConfigUpdate, 
    db: AsyncSession = Depends(get_db)
):
    """Update tournament configuration (e.g., concurrency limit)."""
    success = await tournament_service.update_concurrency(db, id, payload.concurrency)
    if not success:
        raise HTTPException(status_code=404, detail="Tournament not found")
    return {"message": "Tournament configuration updated"}
--- End of File: backend/app/api/tournament.py ---

--- File: backend/app/api/websocket_manager.py ---
"""
Hybrid WebSocket Manager - Background Game Runner Architecture

This manager handles WebSocket connections with hybrid logic:
- Accepts human moves and forwards them to game service
- Broadcasts game state updates to connected clients
- Triggers AI moves for Human vs AI games
- Does NOT drive AI vs AI games (Background Game Runner handles that)
"""

import json
import asyncio
from typing import Dict, List, Set
from fastapi import WebSocket
from sqlalchemy.ext.asyncio import AsyncSession

from backend.app.services.game_service import game_service, GameState
from backend.app.core.database import AsyncSessionLocal


class ConnectionManager:
    def __init__(self):
        # Maps game_id -> List of connected WebSockets
        self.active_connections: Dict[int, List[WebSocket]] = {}
        
        # Track games where AI is currently thinking (for Human vs AI games only)
        self.processing_game_ids: Set[int] = set()
        

    async def connect(self, websocket: WebSocket, game_id: int):
        await websocket.accept()
        if game_id not in self.active_connections:
            self.active_connections[game_id] = []
        self.active_connections[game_id].append(websocket)

    def disconnect(self, websocket: WebSocket, game_id: int):
        if game_id in self.active_connections:
            if websocket in self.active_connections[game_id]:
                self.active_connections[game_id].remove(websocket)
            if not self.active_connections[game_id]:
                del self.active_connections[game_id]
                # Cleanup AI processing lock if exists
                if game_id in self.processing_game_ids:
                    self.processing_game_ids.remove(game_id)

    async def broadcast(self, game_id: int, message: dict):
        """Broadcast message to all connected clients for this game"""
        if game_id in self.active_connections:
            for connection in self.active_connections[game_id][:]:
                try:
                    await connection.send_json(message)
                except Exception:
                    # Remove dead connections
                    pass

    async def handle_game_session(self, websocket: WebSocket, game_id: int, db: AsyncSession):
        """Handle WebSocket connection for a game session - PASSIVE MODE"""
        await self.connect(websocket, game_id)
        
        try:
            # Send initial game state
            try:
                game_db, engine = await game_service.get_game_state(db, game_id)
                current_state = GameState(game_db, engine)
                await websocket.send_json(self._build_state_message(current_state))
                
                # RECOVERY: Check if AI should play after reconnection (for stuck games)
                if game_db.status == "IN_PROGRESS" and not current_state.winner and not current_state.is_draw:
                    await self._check_and_trigger_ai_for_human_vs_ai(game_id, current_state)
                    
            except ValueError as e:
                await websocket.close(code=4004)  # Game not found
                return

            # Listen for human moves only
            while True:
                data = await websocket.receive_text()
                payload = json.loads(data)
                
                if payload.get("action") == "MOVE":
                    await self._handle_human_move(game_id, payload["column"])

        except Exception as e:
            # Silently handle disconnects
            pass
        finally:
            self.disconnect(websocket, game_id)

    async def _handle_human_move(self, game_id: int, column: int):
        """Process a human move and trigger AI response if needed (Human vs AI games)"""
        async with AsyncSessionLocal() as db:
            try:
                # Process human move
                state = await game_service.process_human_move(db, game_id, column)
                
                # Broadcast the updated state
                await self.broadcast(game_id, self._build_state_message(state))
                
                # Check if we should trigger AI for Human vs AI games
                # (Background Game Runner handles AI vs AI games)
                if not state.winner and not state.is_draw:
                    await self._check_and_trigger_ai_for_human_vs_ai(game_id, state)
                    
            except ValueError as e:
                # Invalid move - could send error message to client
                print(f"Invalid move: {e}")
            except Exception as e:
                print(f"Error processing human move: {e}")

    async def _check_and_trigger_ai_for_human_vs_ai(self, game_id: int, current_state: GameState):
        """Check if AI should play next and trigger it (ONLY for Human vs AI games)"""
        # Determine if current turn is AI
        current_ai_model = (current_state.player_1_type if current_state.current_turn == 1 
                          else current_state.player_2_type)
        
        # Only trigger if:
        # 1. Current turn is AI (not human)
        # 2. This is NOT an AI vs AI game (Background Game Runner handles those)
        is_human_vs_ai = (
            (current_state.player_1_type == "human" and current_state.player_2_type != "human") or
            (current_state.player_1_type != "human" and current_state.player_2_type == "human")
        )
        
        if current_ai_model != "human" and is_human_vs_ai and not current_state.winner and not current_state.is_draw:
            # Trigger AI turn for Human vs AI games only
            asyncio.create_task(self._execute_ai_turn_for_human_vs_ai(game_id))

    async def _execute_ai_turn_for_human_vs_ai(self, game_id: int):
        """Execute AI turn for Human vs AI games with proper locking"""
        # 1. LOCK CHECK (prevent double AI turns)
        if game_id in self.processing_game_ids:
            return  # Already thinking! Stop.
            
        self.processing_game_ids.add(game_id)
        
        try:
            await self.broadcast(game_id, {"type": "THINKING_START"})
            
            # 2. PERFORM AI LOGIC
            async with AsyncSessionLocal() as db:
                new_state = await game_service.step_ai_turn(db, game_id)
                
                if new_state:
                    await self.broadcast(game_id, {"type": "THINKING_END"})
                    
                    # 3. BROADCAST UPDATE
                    await self.broadcast(game_id, self._build_state_message(new_state))
                        
        except Exception as e:
            print(f"AI turn error (Human vs AI): {e}")
            await self.broadcast(game_id, {"type": "THINKING_END"})
        finally:
            # 4. RELEASE LOCK
            if game_id in self.processing_game_ids:
                self.processing_game_ids.remove(game_id)

    def _build_state_message(self, state: GameState) -> dict:
        """Build WebSocket message from GameState"""
        return {
            "type": "UPDATE",
            "board": state.board,
            "currentTurn": state.current_turn,
            "winner": state.winner,
            "status": state.status,
            "lastMove": state.last_move
        }


# Singleton instance
manager = ConnectionManager()
--- End of File: backend/app/api/websocket_manager.py ---

--- File: backend/app/core/database.py ---
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
import os
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")

def get_database_url():
    """Helper to retrieve DB URL in scripts context"""
    return DATABASE_URL

engine = create_async_engine(
    DATABASE_URL, 
    echo=False,
    # CHANGE: Increase pool size to handle concurrent games + admin usage
    pool_size=20,     
    max_overflow=20
)
AsyncSessionLocal = sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False
)

Base = declarative_base()

# Dependency for API routes
async def get_db():
    async with AsyncSessionLocal() as session:
        yield session
--- End of File: backend/app/core/database.py ---

--- File: backend/app/engine/ai.py ---
import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field

load_dotenv()

# --- 1. Define Structured Output ---
class MoveDecision(BaseModel):
    reasoning: str = Field(description="your reasoning that lead to the choice. step by step.")
    column: int = Field(description="Column index (0-6).")

# Pricing is in USD per 1 Million Tokens
MODEL_PROVIDERS = {
    # --- OpenAI (Frontier) ---
    "gpt-5.1": {
        "provider": "openai", 
        "label": "GPT-5.1", 
        "context": 128000,
        "pricing": {"input": 1.25, "output": 10.00}
    },
    "gpt-5-mini": {
        "provider": "openai", 
        "label": "GPT-5 Mini", 
        "context": 128000,
        "pricing": {"input": 0.25, "output": 2.00}
    },
    "gpt-5-nano": {
        "provider": "openai", 
        "label": "GPT-5 Nano", 
        "context": 128000,
        "pricing": {"input": 0.05, "output": 0.40}
    },
    "gpt-5": {
        "provider": "openai", 
        "label": "GPT-5", 
        "context": 128000,
        "pricing": {"input":1.25, "output": 10.00}
    },
    "gpt-4.1": {
        "provider": "openai", 
        "label": "GPT-4.1", 
        "context": 128000,
        "pricing": {"input": 2.00, "output": 8.00}
    },
    "gpt-4o": {
        "provider": "openai", 
        "label": "GPT-4o", 
        "context": 128000,
        "pricing": {"input": 2.50, "output": 10.00}
    },

    # --- Google (Gemini) ---
    "gemini-3-pro-preview": {
        "provider": "google", "label": "Gemini 3 Pro", "context": 1048576,
        "pricing": {"input": 2.00, "output": 12.00}
    },
    "gemini-2.5-pro": {
        "provider": "google", "label": "Gemini 2.5 Pro", "context": 1048576,
        "pricing": {"input": 1.25, "output": 10.00}
    },
    "gemini-2.5-flash": {
        "provider": "google", "label": "Gemini 2.5 Flash", "context": 1048576,
        "pricing": {"input": 0.3, "output": 2.5}
    },
    "gemini-2.5-flash-lite": {
        "provider": "google", "label": "Gemini 2.5 Flash-Lite", "context": 1048576,
        "pricing": {"input": 0.1, "output": 0.4}
    },

    # --- Anthropic (Claude) ---
    "claude-sonnet-4.5": {
        "provider": "anthropic", 
        "label": "Claude 4.5 Sonnet", 
        "context": 200000,
        "model_id": "claude-sonnet-4-5-20250929",
        "pricing": {"input": 3.00, "output": 15.00}
    },
    "claude-opus-4.5": {
        "provider": "anthropic", 
        "label": "Claude 4.5 Opus", 
        "context": 200000,
        "model_id": "claude-opus-4-5-20251101",
        "pricing": {"input": 15.00, "output": 75.00}
    },
    "claude-haiku-4.5": {
        "provider": "anthropic", 
        "label": "Claude 4.5 Haiku", 
        "context": 200000,
        "model_id": "claude-haiku-4-5-20251001",
        "pricing": {"input": 0.25, "output": 1.25}
    },

    # --- DeepSeek ---
    "deepseek-v3.2-chat": {
        "provider": "deepseek",
        "label": "DeepSeek V3.2 (Chat)",
        "context": 128000,
        "model_id": "deepseek-chat",
        "api_config": {
            "base_url": "https://api.deepseek.com"
        },
        "pricing": {"input": 0.14, "output": 0.28}  # Very cheap
    },
}

def get_llm(model_key: str, temperature: float = 0.2):
    """
    Factory function to return the correct LangChain Chat Model.
    """
    # 1. Get Config
    config = MODEL_PROVIDERS.get(model_key)
    
    # Auto-detection/Fallback for unknown models
    if not config:
        if "gpt" in model_key:
            provider = "openai"
        elif "claude" in model_key:
            provider = "anthropic"
        elif "gemini" in model_key:
            provider = "google"
        elif "deepseek" in model_key:
            provider = "deepseek"
        else:
            print(f"Warning: Unknown model {model_key}, defaulting to gpt-4o")
            provider = "openai"
            model_key = "gpt-4o"
        
        # Create a dummy config for defaults
        config = {"provider": provider, "model_id": model_key}
    else:
        provider = config["provider"]

    # 2. Resolve Actual API Model ID
    # Use 'model_id' if present (for overrides), otherwise use the dict key
    api_model_name = config.get("model_id", model_key)
    api_flags = config.get("api_config", {})

    # 3. Instantiate Provider Class
    if provider == "openai":
        # Check for custom base_url (future proofing)
        if api_flags.get("base_url"):
            return ChatOpenAI(
                model=api_model_name,
                temperature=temperature,
                base_url=api_flags.get("base_url")
            )
        else:
            return ChatOpenAI(
                model=api_model_name, 
                temperature=temperature
            )

    elif provider == "anthropic":
        return ChatAnthropic(
            model=api_model_name, 
            temperature=temperature
        )

    elif provider == "google":
        return ChatGoogleGenerativeAI(
            model=api_model_name,
            temperature=temperature,
            convert_system_message_to_human=True
        )

    elif provider == "deepseek":
        return ChatOpenAI(
            model=api_model_name,
            temperature=temperature,
            api_key=os.getenv("DEEPSEEK_API_KEY"),
            base_url=api_flags.get("base_url", "https://api.deepseek.com")
        )
    
    else:
        raise ValueError(f"Unsupported provider: {provider}")

# --- 3. Prompt Template ---
SYSTEM_PROMPT = """
You are an expert Connect Four player engine.
You are Player {player_id} (Symbol: {symbol}).
Opponent is Player {opponent_id} (Symbol: {opp_symbol}).
Board: 6 Rows x 7 Columns.
Goal: Connect 4 pieces in a row (Horizontal, Vertical, Diagonal).
Gravity: Pieces fall to the lowest empty slot.
"""

USER_TEMPLATE = """
Board (Visual):
{visual_board}

Board (Textual):
{textual_board}

Valid Columns: {valid_moves}

Analyze the board state carefully. Output valid JSON.
"""

prompt = ChatPromptTemplate.from_messages([
    ("system", SYSTEM_PROMPT),
    ("user", USER_TEMPLATE)
])

class ConnectFourAI:
    def __init__(self, player_id: int, model_name: str = "gpt-4o"):
        self.player_id = player_id
        self.opponent_id = 2 if player_id == 1 else 1
        self.symbol = "X" if player_id == 1 else "O"
        self.opp_symbol = "O" if player_id == 1 else "X"
        self.model_name = model_name
        
        try:
            llm = get_llm(model_name)
            
            # Simple divergence: DeepSeek Chat requires explicit function_calling
            # All other models (OpenAI, Anthropic, Google) use auto-mode.
            if "deepseek" in model_name:
                self.structured_llm = llm.with_structured_output(
                    MoveDecision, 
                    method="function_calling", 
                    include_raw=True
                )
            else:
                self.structured_llm = llm.with_structured_output(MoveDecision, include_raw=True)
            
            self.chain = prompt | self.structured_llm
        except Exception as e:
            print(f"Failed to initialize model {model_name}: {e}")
            fallback_llm = get_llm("gpt-4o")
            self.structured_llm = fallback_llm.with_structured_output(MoveDecision, include_raw=True)
            self.chain = prompt | self.structured_llm

    async def get_move_async(self, game_engine):
        visual = game_engine.get_visual_board()
        textual = game_engine.get_textual_description()
        valid_moves = game_engine.get_valid_moves()

        try:
            result = await self.chain.ainvoke({
                "player_id": self.player_id,
                "opponent_id": self.opponent_id,
                "symbol": self.symbol,
                "opp_symbol": self.opp_symbol,
                "visual_board": visual,
                "textual_board": textual,
                "valid_moves": valid_moves
            })
            
            decision = result['parsed']
            raw_msg = result['raw']
            
            # Validate AI response - guard against empty/None responses
            if not decision:
                raise ValueError("Model returned empty decision")
            
            # Validate decision attributes exist
            if not hasattr(decision, 'column') or not hasattr(decision, 'reasoning'):
                raise ValueError("Model returned incomplete decision object")
            
            # Ensure column is a valid integer
            if not isinstance(decision.column, int):
                raise ValueError(f"Model returned non-integer column: {decision.column}")
            
            usage = getattr(raw_msg, 'usage_metadata', {}) or {"input_tokens": 0, "output_tokens": 0}
            
            # Validation: Column bounds
            if decision.column not in valid_moves:
                import random
                decision.column = random.choice(valid_moves)
                decision.reasoning += " [System: Original move invalid, corrected]"
            
            return {
                "decision": decision,
                "usage": usage
            }

        except Exception as e:
            print(f"AI Error ({self.model_name}): {e}")
            import random
            
            # Capture specific exception message and truncate if too long
            error_msg = str(e)
            clean_error = (error_msg[:100] + '..') if len(error_msg) > 100 else error_msg
            
            fallback_reasoning = (
                f"⚠️ [SYSTEM ERROR] Model {self.model_name} failed. "
                f"Details: {clean_error}. "
                f"Action: Playing random valid move."
            )
            
            fallback = MoveDecision(
                reasoning=fallback_reasoning, 
                column=random.choice(valid_moves)
            )
            return {
                "decision": fallback,
                "usage": {"input_tokens": 0, "output_tokens": 0}
            }
--- End of File: backend/app/engine/ai.py ---

--- File: backend/app/engine/elo.py ---
import math
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from backend.app.models.elo_model import EloRating, EloHistory
from backend.app.models.game_model import Game

K_FACTOR = 32

async def get_or_create_rating(db: AsyncSession, model_name: str) -> EloRating:
    result = await db.execute(select(EloRating).where(EloRating.model_name == model_name))
    rating_obj = result.scalar_one_or_none()
    if not rating_obj:
        rating_obj = EloRating(model_name=model_name, rating=1200.0)
        db.add(rating_obj)
        # We don't commit here, we let the caller commit transactionally
    return rating_obj

def calculate_expected_score(rating_a: float, rating_b: float) -> float:
    return 1 / (1 + 10 ** ((rating_b - rating_a) / 400))

async def update_elo(db: AsyncSession, model_a_name: str, model_b_name: str, winner_id: int, game_id: int):
    """
    Updates ratings for both models after a match.
    winner_id: 1 (Model A), 2 (Model B), or 0 (Draw)
    """
    # 0. IDEMPOTENCY CHECK
    # Check if we have already processed this game to prevent double counting
    existing_history = await db.execute(
        select(EloHistory).where(EloHistory.match_id == game_id)
    )
    if existing_history.first():
        print(f"Skipping ELO update for Game {game_id}: Already processed.")
        return

    # 1. Fetch Current Ratings
    model_a = await get_or_create_rating(db, model_a_name)
    model_b = await get_or_create_rating(db, model_b_name)

    # 2. Calculate Expected Scores
    expected_a = calculate_expected_score(model_a.rating, model_b.rating)
    expected_b = calculate_expected_score(model_b.rating, model_a.rating)

    # 3. Determine Actual Scores (safely handle nullable counters)
    if winner_id == 1:
        score_a, score_b = 1.0, 0.0
        model_a.wins = (model_a.wins or 0) + 1
        model_b.losses = (model_b.losses or 0) + 1
    elif winner_id == 2:
        score_a, score_b = 0.0, 1.0
        model_a.losses = (model_a.losses or 0) + 1
        model_b.wins = (model_b.wins or 0) + 1
    else:
        score_a, score_b = 0.5, 0.5
        model_a.draws = (model_a.draws or 0) + 1
        model_b.draws = (model_b.draws or 0) + 1

    # 4. Update Ratings
    new_rating_a = model_a.rating + K_FACTOR * (score_a - expected_a)
    new_rating_b = model_b.rating + K_FACTOR * (score_b - expected_b)

    model_a.rating = new_rating_a
    model_b.rating = new_rating_b
    model_a.matches_played = (model_a.matches_played or 0) + 1
    model_b.matches_played = (model_b.matches_played or 0) + 1

    # 5. AGGREGATE STATS FROM GAME HISTORY
    # Fetch the game to look at history
    result = await db.execute(select(Game).where(Game.id == game_id))
    game = result.scalar_one()
    
    # Calculate sums for Player 1 (Model A)
    # Filter moves by player 1
    moves_a = [m for m in game.history if m['player'] == 1]
    tokens_a_in = sum(m.get('input_tokens', 0) for m in moves_a)
    tokens_a_out = sum(m.get('output_tokens', 0) for m in moves_a)
    duration_a = sum(m.get('duration', 0.0) for m in moves_a)
    count_moves_a = len(moves_a)

    # Calculate sums for Player 2 (Model B)
    moves_b = [m for m in game.history if m['player'] == 2]
    tokens_b_in = sum(m.get('input_tokens', 0) for m in moves_b)
    tokens_b_out = sum(m.get('output_tokens', 0) for m in moves_b)
    duration_b = sum(m.get('duration', 0.0) for m in moves_b)
    count_moves_b = len(moves_b)

    # Apply updates to Model A
    model_a.total_input_tokens = (model_a.total_input_tokens or 0) + tokens_a_in
    model_a.total_output_tokens = (model_a.total_output_tokens or 0) + tokens_a_out
    model_a.total_moves = (model_a.total_moves or 0) + count_moves_a
    model_a.total_duration_seconds = (model_a.total_duration_seconds or 0.0) + duration_a
    
    # Apply updates to Model B
    model_b.total_input_tokens = (model_b.total_input_tokens or 0) + tokens_b_in
    model_b.total_output_tokens = (model_b.total_output_tokens or 0) + tokens_b_out
    model_b.total_moves = (model_b.total_moves or 0) + count_moves_b
    model_b.total_duration_seconds = (model_b.total_duration_seconds or 0.0) + duration_b

    # 6. Log History (For Graphs)
    hist_a = EloHistory(model_name=model_a_name, rating=new_rating_a, match_id=game_id)
    hist_b = EloHistory(model_name=model_b_name, rating=new_rating_b, match_id=game_id)
    
    db.add(hist_a)
    db.add(hist_b)
    
    # Caller must await db.commit()
--- End of File: backend/app/engine/elo.py ---

--- File: backend/app/engine/game.py ---
import logging
from typing import List, Optional, Tuple, Dict, Any

# Logger setup
logger = logging.getLogger(__name__)

ROWS = 6
COLS = 7

class ConnectFour:
    def __init__(self):
        """
        Board uses (row, col) indexing.
        Row 0 is the TOP of the board.
        Row 5 is the BOTTOM of the board.
        Values: 0=Empty, 1=Player1, 2=Player2
        """
        self.board = [[0 for _ in range(COLS)] for _ in range(ROWS)]
        self.current_turn = 1
        self.winner: Optional[int] = None
        self.history: List[Dict[str, Any]] = []

    def get_valid_moves(self) -> List[int]:
        """Returns a list of column indices (0-6) that are not full."""
        return [c for c in range(COLS) if self.board[0][c] == 0]

    def is_valid_move(self, col: int) -> bool:
        if col < 0 or col >= COLS:
            return False
        return self.board[0][col] == 0

    def drop_piece(self, col: int) -> bool:
        """
        Drops a piece into the specified column. 
        Returns True if successful, False if invalid or game over.
        """
        if self.winner is not None or not self.is_valid_move(col):
            return False

        # Gravity: Find the lowest empty row
        for r in range(ROWS - 1, -1, -1):
            if self.board[r][col] == 0:
                self.board[r][col] = self.current_turn
                
                # Record move logic (metadata will be added by API layer later)
                self.history.append({
                    "player": self.current_turn,
                    "column": col
                })

                if self.check_win(r, col):
                    self.winner = self.current_turn
                else:
                    self.switch_turn()
                return True
        return False

    def switch_turn(self):
        self.current_turn = 1 if self.current_turn == 2 else 2

    def check_win(self, r: int, c: int) -> bool:
        """Checks for 4-in-a-row originating from the placed piece."""
        player = self.board[r][c]
        # Directions: Horizontal, Vertical, Diagonal /, Diagonal \
        directions = [(0, 1), (1, 0), (1, -1), (1, 1)]

        for dr, dc in directions:
            count = 1
            # Check positive direction
            for i in range(1, 4):
                nr, nc = r + dr * i, c + dc * i
                if 0 <= nr < ROWS and 0 <= nc < COLS and self.board[nr][nc] == player:
                    count += 1
                else:
                    break
            # Check negative direction
            for i in range(1, 4):
                nr, nc = r - dr * i, c - dc * i
                if 0 <= nr < ROWS and 0 <= nc < COLS and self.board[nr][nc] == player:
                    count += 1
                else:
                    break
            
            if count >= 4:
                return True
        return False

    def is_draw(self) -> bool:
        """Returns True if board is full and no winner."""
        return self.winner is None and all(self.board[0][c] != 0 for c in range(COLS))

    # --- Formatting for LLM Consumption ---

    def get_visual_board(self) -> str:
        """Generates an ASCII grid representation."""
        symbols = {0: ".", 1: "X", 2: "O"}
        header = " " + " ".join([str(i) for i in range(COLS)])
        rows_str = []
        for r in range(ROWS):
            row_cells = [symbols[self.board[r][c]] for c in range(COLS)]
            rows_str.append("|" + "|".join(row_cells) + "|")
        return header + "\n" + "\n".join(rows_str)

    def get_textual_description(self) -> str:
        """
        Describes the board column by column, listing pieces from Bottom to Top.
        Example: 'Col 0: P1, P2, Empty'
        """
        lines = []
        for c in range(COLS):
            pieces = []
            # Scan from Bottom (Row 5) to Top (Row 0)
            for r in range(ROWS - 1, -1, -1):
                val = self.board[r][c]
                if val == 0:
                    break # Stop at first empty space
                pieces.append("P1" if val == 1 else "P2")
            
            desc = ", ".join(pieces) if pieces else "Empty"
            lines.append(f"Column {c}: {desc}")
        return "\n".join(lines)
--- End of File: backend/app/engine/game.py ---

--- File: backend/app/models/elo_model.py ---
from sqlalchemy import Column, Integer, String, Float, DateTime, BigInteger # Added BigInteger
from sqlalchemy.sql import func
from backend.app.core.database import Base

class EloRating(Base):
    __tablename__ = "elo_ratings"

    model_name = Column(String, primary_key=True, index=True)
    rating = Column(Float, default=1200.0)
    matches_played = Column(Integer, default=0)
    wins = Column(Integer, default=0)
    losses = Column(Integer, default=0)
    draws = Column(Integer, default=0)
    
    # --- Token Usage ---
    total_input_tokens = Column(BigInteger, default=0)
    total_output_tokens = Column(BigInteger, default=0)
    
    # --- NEW: Time & Move Stats for Averages ---
    total_moves = Column(BigInteger, default=0)
    total_duration_seconds = Column(Float, default=0.0)
    # -------------------------------------------
    
    last_updated = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

class EloHistory(Base):
    """
    Time-series data for the graph. 
    A row is inserted every time a model finishes a ranked match.
    """
    __tablename__ = "elo_history"

    id = Column(Integer, primary_key=True, index=True)
    model_name = Column(String, index=True) # Foreign key logic handled manually or via string match
    rating = Column(Float)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    match_id = Column(Integer, nullable=True) # Reference to the Game ID
--- End of File: backend/app/models/elo_model.py ---

--- File: backend/app/models/game_model.py ---
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from backend.app.core.database import Base

class Game(Base):
    __tablename__ = "games"

    id = Column(Integer, primary_key=True, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Tournament Links
    tournament_id = Column(Integer, ForeignKey("tournaments.id"), nullable=True)
    round_number = Column(Integer, nullable=True) # For round-robin tracking
    
    tournament = relationship("Tournament", back_populates="games")

    # Metadata
    player_1_type = Column(String, default="human") 
    player_2_type = Column(String, default="ai")
    
    # Game State
    winner = Column(Integer, nullable=True)
    status = Column(String, default="IN_PROGRESS") # IN_PROGRESS, COMPLETED, DRAW, PENDING
    
    history = Column(JSONB, default=list)
--- End of File: backend/app/models/game_model.py ---

--- File: backend/app/models/tournament_model.py ---
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from backend.app.core.database import Base

class Tournament(Base):
    __tablename__ = "tournaments"

    id = Column(Integer, primary_key=True, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    status = Column(String, default="SETUP") # SETUP, IN_PROGRESS, PAUSED, COMPLETED, STOPPED
    
    # Config: { "concurrency": 5, "rounds": 2, "models": [...] }
    config = Column(JSONB, default=dict)
    
    total_matches = Column(Integer, default=0)
    
    # Relationship
    games = relationship("Game", back_populates="tournament", cascade="all, delete-orphan")
--- End of File: backend/app/models/tournament_model.py ---

--- File: backend/app/schemas/game_schema.py ---
from pydantic import BaseModel, ConfigDict
from typing import List, Optional, Any
from datetime import datetime

class MoveRecord(BaseModel):
    # Allow extra fields in the JSON to prevent crashes if schema evolves
    model_config = ConfigDict(extra='ignore') 

    player: int
    column: int
    reasoning: Optional[str] = None
    
    # Allow None to be coerced to 0, or handle optional integers gracefully
    input_tokens: Optional[int] = 0
    output_tokens: Optional[int] = 0
    
    # --- ADDED THIS FIELD ---
    duration: Optional[float] = 0.0

class GameCreate(BaseModel):
    player_1: str = "human"
    player_2: str = "ai"

class GameResponse(BaseModel):
    id: int
    status: str
    winner: Optional[int] = None # Ensure explicit default
    
    # Use MoveRecord with relaxed validation to prevent 422s on malformed history data
    history: List[MoveRecord] 
    
    created_at: datetime
    player_1_type: str
    player_2_type: str

    class Config:
        from_attributes = True
--- End of File: backend/app/schemas/game_schema.py ---

--- File: backend/app/services/__init__.py ---
# Services package
--- End of File: backend/app/services/__init__.py ---

--- File: backend/app/services/game_runner.py ---
"""
Game Runner - Background Worker System

This service runs AI vs AI games in the background, independent of WebSocket connections.
It automatically resumes interrupted games on server startup and ensures games complete
even if users close their browsers.
"""

import asyncio
from sqlalchemy.future import select
from backend.app.core.database import AsyncSessionLocal
from backend.app.models.game_model import Game
from backend.app.services.game_service import game_service, GameState


class GameRunner:
    def __init__(self):
        self.running_tasks = {}  # game_id -> asyncio.Task

    async def start_game_if_ai_vs_ai(self, game_id: int):
        """Checks if a game is AI vs AI and starts the background loop if so."""
        async with AsyncSessionLocal() as db:
            game, _ = await game_service.get_game_state(db, game_id)
            
            # Condition: Both players are AI
            is_ai_vs_ai = (game.player_1_type != "human" and game.player_2_type != "human")
            
            if is_ai_vs_ai and game.status == "IN_PROGRESS":
                if game_id not in self.running_tasks:
                    print(f"🚀 Starting Background Runner for Game {game_id}")
                    self.running_tasks[game_id] = asyncio.create_task(self._game_loop(game_id))

    async def _game_loop(self, game_id: int):
        """The main loop that plays the game until completion."""
        # Late import to avoid circular imports
        from backend.app.api.websocket_manager import manager
        
        try:
            while True:
                # 1. Brief pause to simulate thinking/pacing
                await asyncio.sleep(1.5)

                async with AsyncSessionLocal() as db:
                    # 2. Execute Step
                    # Note: step_ai_turn handles locking and validation internally
                    new_state = await game_service.step_ai_turn(db, game_id)
                    
                    if not new_state:
                        # Game likely finished or error
                        break

                    # 3. Broadcast to anyone watching
                    await manager.broadcast(game_id, {
                        "type": "UPDATE",
                        "board": new_state.board,
                        "currentTurn": new_state.current_turn,
                        "winner": new_state.winner,
                        "status": new_state.status,
                        "lastMove": new_state.last_move
                    })

                    # 4. Check Exit Conditions
                    if new_state.winner or new_state.is_draw or new_state.status != "IN_PROGRESS":
                        print(f"🏁 Game {game_id} Finished in background.")
                        break
                        
        except asyncio.CancelledError:
            # Game was paused/cancelled - don't mark as failed, just exit
            print(f"⏸️ Game {game_id} Paused/Cancelled")
            raise  # Re-raise to ensure proper cleanup
        except Exception as e:
            print(f"❌ Background Runner Error (Game {game_id}): {e}")
        finally:
            if game_id in self.running_tasks:
                del self.running_tasks[game_id]

    def is_game_running(self, game_id: int) -> bool:
        """Check if a game is currently being processed in background."""
        return game_id in self.running_tasks

    async def stop_game(self, game_id: int):
        """Stop background processing for a specific game."""
        if game_id in self.running_tasks:
            self.running_tasks[game_id].cancel()
            del self.running_tasks[game_id]
            print(f"🛑 Stopped Background Runner for Game {game_id}")


# Singleton
game_runner = GameRunner()
--- End of File: backend/app/services/game_runner.py ---

--- File: backend/app/services/game_service.py ---
"""
Game Service - Centralized Game Logic

This service is the single source of truth for all game state modifications.
It handles:
- Game creation
- Move processing (human and AI)
- Database updates 
- ELO calculations
- Game completion logic

Used by both WebSocket manager (live games) and tournament scripts (background games).
"""

import asyncio
import time
from typing import Dict, Any, Optional, Tuple
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm.attributes import flag_modified

from backend.app.models.game_model import Game
from backend.app.engine.game import ConnectFour
from backend.app.engine.ai import ConnectFourAI
from backend.app.engine.elo import update_elo


class GameState:
    """Represents the current state of a game for API responses"""
    def __init__(self, game_db: Game, engine: ConnectFour):
        self.game_id = game_db.id
        self.board = engine.board
        self.current_turn = engine.current_turn
        self.winner = engine.winner
        self.status = game_db.status
        self.is_draw = engine.is_draw()
        self.last_move = game_db.history[-1] if game_db.history else None
        self.player_1_type = game_db.player_1_type
        self.player_2_type = game_db.player_2_type


class GameService:
    """Centralized service for all game operations"""
    
    async def create_game(self, db: AsyncSession, player_1_type: str, player_2_type: str) -> Game:
        """Create a new game in the database"""
        new_game = Game(
            player_1_type=player_1_type,
            player_2_type=player_2_type,
            history=[]
        )
        db.add(new_game)
        await db.commit()
        await db.refresh(new_game)
        return new_game
    
    async def get_game_state(self, db: AsyncSession, game_id: int) -> Tuple[Game, ConnectFour]:
        """Load game from DB and reconstruct engine state (READ ONLY)"""
        result = await db.execute(select(Game).where(Game.id == game_id))
        game_db = result.scalar_one_or_none()
        
        if not game_db:
            raise ValueError(f"Game {game_id} not found")
        
        # Reconstruct game engine from history
        engine = ConnectFour()
        for move in game_db.history:
            engine.drop_piece(move['column'])
            
        return game_db, engine
    
    async def _get_game_for_update(self, db: AsyncSession, game_id: int) -> Tuple[Game, ConnectFour]:
        """
        Load game from DB with row locking (FOR UPDATE).
        This prevents other transactions from modifying the game while we process a move.
        """
        result = await db.execute(select(Game).where(Game.id == game_id).with_for_update())
        game_db = result.scalar_one_or_none()
        
        if not game_db:
            raise ValueError(f"Game {game_id} not found")
            
        engine = ConnectFour()
        for move in game_db.history:
            engine.drop_piece(move['column'])
            
        return game_db, engine

    async def process_human_move(self, db: AsyncSession, game_id: int, column: int) -> GameState:
        """Process a human player's move with locking"""
        # Start timer for human (optional, but keeps data consistent)
        start_time = time.time()
        
        # Acquire Lock immediately
        game_db, engine = await self._get_game_for_update(db, game_id)
        
        if game_db.status != "IN_PROGRESS":
            return GameState(game_db, engine)

        # Validate move
        if not engine.drop_piece(column):
            raise ValueError(f"Invalid move: column {column}")
        
        end_time = time.time()
        duration = round(end_time - start_time, 3)
        
        # Create move record
        move_record = {
            "player": engine.current_turn - 1 if engine.current_turn == 2 else 1,  # Previous player
            "column": column,
            "reasoning": None,
            "input_tokens": 0,
            "output_tokens": 0,
            "duration": duration  # <--- Added Duration
        }
        
        # Save move
        await self._save_move_to_db(db, game_db, move_record, engine)
        
        return GameState(game_db, engine)
    
    async def step_ai_turn(self, db: AsyncSession, game_id: int) -> Optional[GameState]:
        """Execute one AI turn and return new game state"""
        
        # 1. READ (No Lock) - Get snapshot for LLM to think
        try:
            game_db_snapshot, engine_snapshot = await self.get_game_state(db, game_id)
        except ValueError:
            return None

        # Check if game is already finished
        if engine_snapshot.winner or engine_snapshot.is_draw() or game_db_snapshot.status != "IN_PROGRESS":
            return GameState(game_db_snapshot, engine_snapshot)
        
        # Determine which AI should play
        current_player = engine_snapshot.current_turn
        ai_model = game_db_snapshot.player_1_type if current_player == 1 else game_db_snapshot.player_2_type
        
        # Skip if current player is human
        if ai_model == "human":
            return GameState(game_db_snapshot, engine_snapshot)
        
        # --- TIMER START ---
        start_time = time.time()
        
        # 2. THINK (Slow Operation - No DB Lock held)
        ai_agent = ConnectFourAI(player_id=current_player, model_name=ai_model)
        
        try:
            result = await ai_agent.get_move_async(engine_snapshot)
            decision = result["decision"]
            usage = result["usage"]
            
            # --- TIMER END ---
            end_time = time.time()
            duration = round(end_time - start_time, 3)
            
            # 3. WRITE (Acquire Lock) - Re-validate and Save
            # This ensures that if the state changed while AI was thinking, we handle it correctly
            game_db, engine = await self._get_game_for_update(db, game_id)
            
            # Re-verification inside lock
            if game_db.status != "IN_PROGRESS":
                print(f"Game {game_id} finished while AI was thinking.")
                return GameState(game_db, engine)
                
            if engine.current_turn != current_player:
                print(f"Turn changed while AI was thinking (Race condition prevented).")
                return GameState(game_db, engine)

            # Validate and execute move on the LOCKED engine
            if not engine.drop_piece(decision.column):
                print(f"AI generated invalid move for current board state: {decision.column}")
                # Optional: Retry logic could go here. For now, we abort the turn.
                return GameState(game_db, engine)
            
            # Create move record
            move_record = {
                "player": current_player,
                "column": decision.column,
                "reasoning": decision.reasoning,
                "input_tokens": usage.get("input_tokens", 0),
                "output_tokens": usage.get("output_tokens", 0),
                "duration": duration  # <--- Added Duration
            }
            
            # Save move
            await self._save_move_to_db(db, game_db, move_record, engine)
            
            return GameState(game_db, engine)
            
        except Exception as e:
            print(f"AI turn failed for {ai_model}: {e}")
            # Don't raise here, just return current state so game doesn't crash
            return GameState(game_db_snapshot, engine_snapshot)
    
    
    async def _save_move_to_db(self, db: AsyncSession, game_db: Game, move_record: Dict[str, Any], engine: ConnectFour):
        """Save move to database with transaction safety"""
        try:
            # Update history
            new_history = list(game_db.history)
            new_history.append(move_record)
            game_db.history = new_history
            flag_modified(game_db, "history")  # Ensure SQLAlchemy detects JSONB changes
            
            # Update game status if finished
            if engine.winner:
                game_db.winner = engine.winner
                game_db.status = "COMPLETED"
            elif engine.is_draw():
                game_db.status = "DRAW"
            
            # Handle ELO updates for all completed games BEFORE committing
            if game_db.status in ["COMPLETED", "DRAW"]:
                
                winner_id = engine.winner if engine.winner else 0  # 0 for draw
                
                # The update_elo function now handles idempotency internally
                await update_elo(
                    db,
                    game_db.player_1_type,
                    game_db.player_2_type,
                    winner_id,
                    game_db.id
                )
            
            # Single atomic commit for both game result and ELO updates
            await db.commit()
            await db.refresh(game_db)
            
        except Exception as e:
            print(f"DB Save Error: {e}")
            await db.rollback()
            raise ValueError(f"Failed to save move: {e}")


# Singleton instance
game_service = GameService()
--- End of File: backend/app/services/game_service.py ---

--- File: backend/app/services/tournament_service.py ---
import random
import asyncio
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import func, and_
from typing import List

from backend.app.models.tournament_model import Tournament
from backend.app.models.game_model import Game
from backend.app.services.game_runner import game_runner

class TournamentService:
    async def create_tournament(
        self, 
        db: AsyncSession, 
        models: List[str], 
        rounds: int, 
        concurrency: int
    ) -> Tournament:
        """
        Generates the schedule and creates the Tournament record + PENDING games.
        Does NOT start them yet.
        """
        # 1. Create Tournament Record
        config = {
            "model_ids": models,
            "rounds": rounds,
            "concurrency": concurrency
        }
        
        # Calculate total math for validation
        n = len(models)
        matches_per_round = n * (n - 1) 
        total_games = matches_per_round * rounds

        tournament = Tournament(
            status="SETUP",
            config=config,
            total_matches=total_games
        )
        db.add(tournament)
        await db.commit()
        await db.refresh(tournament)

        # 2. Generate Schedule (Round Robin)
        games_to_create = []
        
        for r in range(1, rounds + 1):
            # Create all pairs for this round
            round_pairs = []
            for i in range(len(models)):
                for j in range(len(models)):
                    if i == j: continue # Can't play self
                    
                    # Model A vs Model B
                    p1 = models[i]
                    p2 = models[j]
                    
                    round_pairs.append({
                        "p1": p1,
                        "p2": p2,
                        "round": r
                    })
            
            # Shuffle pairs within the round to avoid "Model A plays 10 times in a row"
            random.shuffle(round_pairs)
            
            for pair in round_pairs:
                games_to_create.append(Game(
                    tournament_id=tournament.id,
                    round_number=pair["round"],
                    player_1_type=pair["p1"],
                    player_2_type=pair["p2"],
                    status="PENDING", # Waiting for runner
                    history=[]
                ))

        # Bulk insert is faster
        db.add_all(games_to_create)
        await db.commit()
        
        return tournament

    async def start_tournament(self, db: AsyncSession, tournament_id: int):
        result = await db.execute(select(Tournament).where(Tournament.id == tournament_id))
        t = result.scalar_one_or_none()
        if t:
            t.status = "IN_PROGRESS"
            await db.commit()
            return True
        return False

    async def stop_tournament(self, db: AsyncSession, tournament_id: int):
        result = await db.execute(select(Tournament).where(Tournament.id == tournament_id))
        t = result.scalar_one_or_none()
        if t:
            t.status = "STOPPED"
            await db.commit()
            # Also cancel all pending games? Optional.
            return True
        return False

    async def pause_tournament(self, db: AsyncSession, tournament_id: int):
        """Pause a tournament - stops all running games but preserves state."""
        result = await db.execute(select(Tournament).where(Tournament.id == tournament_id))
        t = result.scalar_one_or_none()
        if not t:
            return False
        
        # Update tournament status
        t.status = "PAUSED"
        await db.commit()
        
        # Find all IN_PROGRESS games for this tournament
        games_query = await db.execute(
            select(Game).where(
                Game.tournament_id == tournament_id,
                Game.status == "IN_PROGRESS"
            )
        )
        games = games_query.scalars().all()
        
        # Stop all running games in GameRunner
        for game in games:
            await game_runner.stop_game(game.id)
        
        print(f"⏸️ Tournament {tournament_id} Paused ({len(games)} games stopped)")
        return True

    async def update_concurrency(self, db: AsyncSession, tournament_id: int, new_concurrency: int):
        """Update concurrency limit for a tournament."""
        result = await db.execute(select(Tournament).where(Tournament.id == tournament_id))
        t = result.scalar_one_or_none()
        if not t:
            return False
        
        # Update concurrency in config
        if "concurrency" not in t.config:
            t.config["concurrency"] = new_concurrency
        else:
            t.config["concurrency"] = new_concurrency
        
        await db.commit()
        print(f"⚙️ Tournament {tournament_id} concurrency updated to {new_concurrency}")
        return True

    async def tick(self, db: AsyncSession):
        """
        The Heartbeat. Checks active tournament and feeds games to the runner.
        Called periodically by main.py
        """
        # 1. Find active tournament
        result = await db.execute(
            select(Tournament).where(Tournament.status == "IN_PROGRESS")
        )
        active_tournament = result.scalars().first()
        
        if not active_tournament:
            return

        concurrency_limit = active_tournament.config.get("concurrency", 1)
        
        # 2. Get all IN_PROGRESS games for this tournament
        active_games_query = await db.execute(
            select(Game).where(
                and_(
                    Game.tournament_id == active_tournament.id,
                    Game.status == "IN_PROGRESS"
                )
            )
        )
        active_games_db = active_games_query.scalars().all()
        
        # 3. Count games actually running in memory (GameRunner)
        current_running = 0
        orphaned_games = []
        for game in active_games_db:
            if game_runner.is_game_running(game.id):
                current_running += 1
            else:
                orphaned_games.append(game)
        
        slots_available = concurrency_limit - current_running
        
        if slots_available > 0:
            games_to_start = []
            
            # 4. First, fill slots with orphaned games (resume paused games)
            for game in orphaned_games:
                if slots_available <= 0:
                    break
                games_to_start.append(game)
                slots_available -= 1
            
            # 5. If slots still available, fetch PENDING games
            if slots_available > 0:
                pending_query = await db.execute(
                    select(Game)
                    .where(
                        and_(
                            Game.tournament_id == active_tournament.id,
                            Game.status == "PENDING"
                        )
                    )
                    .order_by(Game.round_number.asc(), Game.id.asc())
                    .limit(slots_available)
                )
                pending_games = pending_query.scalars().all()
                games_to_start.extend(pending_games)
            
            if not games_to_start and current_running == 0:
                # No running games, no pending games -> Tournament Complete
                active_tournament.status = "COMPLETED"
                await db.commit()
                print(f"🏆 Tournament {active_tournament.id} Completed!")
                return

            # 6. Launch them
            for game in games_to_start:
                if game.status == "PENDING":
                    game.status = "IN_PROGRESS"
                    await db.commit() # Commit status change first so other workers don't grab it
                
                print(f"🚀 Tournament Launching: Game {game.id} (Round {game.round_number})")
                await game_runner.start_game_if_ai_vs_ai(game.id)

tournament_service = TournamentService()
--- End of File: backend/app/services/tournament_service.py ---

--- File: backend/app/main.py ---
from fastapi import FastAPI, WebSocket, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import or_
from typing import List
from contextlib import asynccontextmanager
import asyncio

from backend.app.core.database import get_db, AsyncSessionLocal
from backend.app.models.game_model import Game
from backend.app.schemas.game_schema import GameCreate, GameResponse
from backend.app.api.websocket_manager import manager
from backend.app.api.stats import router as stats_router
from backend.app.api.admin import router as admin_router
from backend.app.api.tournament import router as tournament_router
from backend.app.engine.ai import MODEL_PROVIDERS
from backend.app.services.game_runner import game_runner
from backend.app.services.game_service import GameState
from backend.app.services.tournament_service import tournament_service

# --- LIFESPAN MANAGER (Auto-Resume on Startup) ---
async def tournament_watcher():
    """Background task to feed the tournament"""
    while True:
        try:
            async with AsyncSessionLocal() as db:
                await tournament_service.tick(db)
        except Exception as e:
            print(f"Tournament Loop Error: {e}")
        
        await asyncio.sleep(2) # Check every 2 seconds

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: Find all IN_PROGRESS AI vs AI games and resume them
    print("🔄 Checking for interrupted games...")
    async with AsyncSessionLocal() as db:
        query = select(Game).where(
            Game.status == "IN_PROGRESS",
            Game.player_1_type != "human",
            Game.player_2_type != "human"
        )
        result = await db.execute(query)
        games = result.scalars().all()
        
        for game in games:
            print(f"▶️ Resuming Game {game.id}")
            await game_runner.start_game_if_ai_vs_ai(game.id)
    
    # NEW: Start Tournament Watcher
    asyncio.create_task(tournament_watcher())
            
    yield
    # Shutdown logic (optional)
# -------------------------------------------------

app = FastAPI(title="Connect Four LLM Arena", lifespan=lifespan)

# --- ADD CORS MIDDLEWARE HERE ---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000"], # Allow Vite (5173) and React default (3000)
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# --------------------------------

# Register routers
app.include_router(stats_router, prefix="/stats", tags=["Stats"])
app.include_router(admin_router, prefix="/admin", tags=["Admin"])
app.include_router(tournament_router, prefix="/tournament", tags=["Tournament"])

# --- NEW ENDPOINT ---
@app.get("/models")
async def get_available_models():
    """Returns the list of supported LLMs and their display labels."""
    # Transform dict to list of objects for easier frontend consumption
    return [
        {"id": key, "provider": val["provider"], "label": val["label"]}
        for key, val in MODEL_PROVIDERS.items()
    ]
# --------------------

@app.post("/games", response_model=GameResponse)
async def create_game(game_data: GameCreate, db: AsyncSession = Depends(get_db)):
    new_game = Game(
        player_1_type=game_data.player_1,
        player_2_type=game_data.player_2,
        history=[]
    )
    db.add(new_game)
    await db.commit()
    await db.refresh(new_game)
    
    # --- TRIGGER BACKGROUND RUNNER ---
    # If it's AI vs AI, start the background loop immediately.
    # The user doesn't even need to open the websocket.
    await game_runner.start_game_if_ai_vs_ai(new_game.id)
    # ---------------------------------
    
    return new_game

# --- FIX: Move this endpoint UP, before /games/{game_id} ---
@app.get("/games/history", response_model=List[GameResponse])
async def get_game_history(
    skip: int = 0, 
    limit: int = 50, 
    db: AsyncSession = Depends(get_db)
):
    """
    Fetch completed games (COMPLETED or DRAW) for the history tab.
    Sorted by newest first.
    """
    query = select(Game).where(
        Game.status.in_(["COMPLETED", "DRAW"])
    ).order_by(Game.created_at.desc()).offset(skip).limit(limit)
    result = await db.execute(query)
    games = result.scalars().all()
    return games
# -----------------------------------------------------------

@app.get("/games/pending-human", response_model=List[int])
async def get_pending_human_games(db: AsyncSession = Depends(get_db)):
    """
    Returns a list of Game IDs where it is currently a human's turn.
    Used for the 'Next Actionable Game' navigation feature.
    """
    # Fetch all IN_PROGRESS games involving at least one human
    query = select(Game).where(
        Game.status == "IN_PROGRESS",
        or_(Game.player_1_type == "human", Game.player_2_type == "human")
    ).order_by(Game.id)
    
    result = await db.execute(query)
    games = result.scalars().all()
    
    actionable_ids = []
    
    for game in games:
        # --- FIX: Handle None history safely ---
        history = game.history if game.history is not None else []
        move_count = len(history)
        
        is_p1_turn = (move_count % 2) == 0
        
        is_p1_human = game.player_1_type == "human"
        is_p2_human = game.player_2_type == "human"
        
        # Check if it's a human's turn
        if (is_p1_turn and is_p1_human) or (not is_p1_turn and is_p2_human):
            actionable_ids.append(game.id)
            
    return actionable_ids

@app.get("/games/{game_id}", response_model=GameResponse)
async def get_game(game_id: int, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Game).where(Game.id == game_id))
    game = result.scalar_one_or_none()
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")
    return game

@app.get("/games", response_model=List[GameResponse])
async def list_games(status: str = "IN_PROGRESS", limit: int = 20, db: AsyncSession = Depends(get_db)):
    """List games by status. Useful for finding active AI vs AI games to spectate."""
    query = select(Game).where(Game.status == status).order_by(Game.created_at.desc()).limit(limit)
    result = await db.execute(query)
    games = result.scalars().all()
    return games

@app.post("/games/{game_id}/recover")
async def recover_stuck_game(game_id: int, db: AsyncSession = Depends(get_db)):
    """Manually trigger recovery for a stuck Human vs AI game"""
    try:
        game_db, engine = await game_service.get_game_state(db, game_id)
        current_state = GameState(game_db, engine)
        
        # Only recover Human vs AI games that are in progress
        is_human_vs_ai = (
            (game_db.player_1_type == "human" and game_db.player_2_type != "human") or
            (game_db.player_1_type != "human" and game_db.player_2_type == "human")
        )
        
        if game_db.status == "IN_PROGRESS" and is_human_vs_ai and not current_state.winner and not current_state.is_draw:
            # Determine if it's AI's turn
            current_ai_model = (current_state.player_1_type if current_state.current_turn == 1 
                              else current_state.player_2_type)
            
            if current_ai_model != "human":
                # Trigger AI move
                new_state = await game_service.step_ai_turn(db, game_id)
                if new_state:
                    await manager.broadcast(game_id, manager._build_state_message(new_state))
                    return {"message": "Game recovered successfully", "ai_moved": True}
                else:
                    return {"message": "Failed to execute AI move", "ai_moved": False}
            else:
                return {"message": "It's human's turn, no recovery needed", "ai_moved": False}
        else:
            return {"message": "Game doesn't need recovery", "ai_moved": False}
            
    except ValueError:
        raise HTTPException(status_code=404, detail="Game not found")

@app.websocket("/games/{game_id}/ws")
async def game_websocket(websocket: WebSocket, game_id: int, db: AsyncSession = Depends(get_db)):
    await manager.handle_game_session(websocket, game_id, db)
--- End of File: backend/app/main.py ---

--- File: backend/scripts/cleanup_games.py ---
#!/usr/bin/env python3
"""
Global Janitor Script for Connect Four Games

This script finds and marks old IN_PROGRESS games as ABANDONED.
Games older than 1 hour that are still IN_PROGRESS are considered stale
and will be marked as ABANDONED to prevent database bloat.

Usage:
    python backend/scripts/cleanup_games.py
"""

import asyncio
import sys
import os
from datetime import datetime, timedelta

# Add parent directories to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import sessionmaker
from backend.app.models.game_model import Game
from backend.app.core.database import get_database_url

async def cleanup_abandoned_games():
    """
    Find and mark games as ABANDONED if they are:
    - Status is IN_PROGRESS
    - Created more than 1 hour ago
    """
    # Initialize database connection
    engine = create_async_engine(get_database_url())
    async_session_maker = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
    
    async with async_session_maker() as db:
        try:
            # Calculate cutoff time (1 hour ago)
            cutoff_time = datetime.utcnow() - timedelta(hours=1)
            
            # Query for old IN_PROGRESS games
            result = await db.execute(
                select(Game).where(
                    Game.status == 'IN_PROGRESS',
                    Game.created_at < cutoff_time
                )
            )
            stale_games = result.scalars().all()
            
            if not stale_games:
                print("No stale games found. Database is clean.")
                return
            
            # Update each stale game to ABANDONED
            abandoned_count = 0
            for game in stale_games:
                print(f"Marking game {game.id} as ABANDONED (created: {game.created_at})")
                game.status = "ABANDONED"
                abandoned_count += 1
            
            # Commit all changes
            await db.commit()
            print(f"✅ Successfully marked {abandoned_count} games as ABANDONED")
            
        except Exception as e:
            print(f"❌ Error during cleanup: {e}")
            await db.rollback()
        finally:
            await engine.dispose()

if __name__ == "__main__":
    print("🧹 Starting Connect Four game cleanup...")
    asyncio.run(cleanup_abandoned_games())
    print("🧹 Cleanup complete!")
--- End of File: backend/scripts/cleanup_games.py ---

--- File: backend/scripts/init_db.py ---
import asyncio
from backend.app.core.database import engine, Base
# IMPORT ALL MODELS
from backend.app.models.game_model import Game
from backend.app.models.elo_model import EloRating, EloHistory 
from backend.app.models.tournament_model import Tournament # <--- NEW

async def init_models():
    async with engine.begin() as conn:
        # For Dev: Drop to ensure schema update (WARNING: DELETES DATA)
        # If you want to keep data, you must use Alembic or SQL ALTER commands manually.
        # For this feature, I recommend a clean slate if possible.
        # await conn.run_sync(Base.metadata.drop_all) 
        
        # Safe create (only creates if missing)
        await conn.run_sync(Base.metadata.create_all)
        print("Database tables updated.")

if __name__ == "__main__":
    asyncio.run(init_models())
--- End of File: backend/scripts/init_db.py ---

--- File: backend/scripts/test_models.py ---
import asyncio
import os
import sys

# Add project root to path so we can import from backend.app
sys.path.append(os.path.join(os.path.dirname(__file__), '../../'))

from backend.app.engine.ai import MODEL_PROVIDERS, get_llm

async def test_model(name, config):
    print(f"Testing {name} [{config['provider']}]...", end=" ", flush=True)
    try:
        llm = get_llm(name)
        # Send a tiny prompt to verify connectivity
        await llm.ainvoke("Hi")
        print("✅ OK")
        return True
    except Exception as e:
        print(f"❌ FAILED")
        print(f"   Error: {str(e)}")
        return False

async def main():
    print("--- Verifying Model Configurations ---")
    results = []
    
    # Sort keys for consistent output
    sorted_models = sorted(MODEL_PROVIDERS.items())
    
    for name, config in sorted_models:
        success = await test_model(name, config)
        results.append(success)
        
    print("-" * 30)
    print(f"Passed: {sum(results)} / {len(results)}")

if __name__ == "__main__":
    asyncio.run(main())
--- End of File: backend/scripts/test_models.py ---

--- File: backend/scripts/verify_ai_moves.py ---
#!/usr/bin/env python3
"""
AI Model Structured Output Verification Script - Parallel Version

This script validates that all configured LLM providers can successfully generate
structured JSON outputs (MoveDecision) within the Connect Four game engine context.

Features:
- Parallel execution with configurable concurrency limits
- Rate limiting via asyncio.Semaphore to prevent API 429 errors
- Real-time result output as tests complete
- Comprehensive validation of structured outputs

Exit Codes:
  0: All models passed
  1: One or more models failed
"""

import asyncio
import sys
import os
import logging
from typing import Tuple

# Add project root to path so we can import from backend.app
sys.path.append(os.path.join(os.path.dirname(__file__), '../../'))

# Suppress HTTP request logs for cleaner output
logging.getLogger("httpx").setLevel(logging.WARNING)

from backend.app.engine.ai import MODEL_PROVIDERS, ConnectFourAI
from backend.app.engine.game import ConnectFour

# --- Configuration ---
CONCURRENCY_LIMIT = 50  # Adjust based on your API tier limits


async def test_model_generation(model_key: str) -> Tuple[str, bool, str]:
    """
    Test a single model's ability to generate structured outputs in a game context.
    
    Args:
        model_key: The model identifier (e.g., "gpt-4o", "deepseek-v3.2-chat")
        
    Returns:
        Tuple of (Model Name, Success Boolean, Error Message)
    """
    # 1. Setup Board - Simulate mid-game state (not empty board)
    engine = ConnectFour()
    engine.drop_piece(3)  # Player 1 move
    engine.drop_piece(2)  # Player 2 move  
    engine.drop_piece(3)  # Player 1 move
    
    try:
        # 2. Initialize AI Agent
        ai = ConnectFourAI(player_id=2, model_name=model_key)
        
        # 3. Execute AI Move Generation
        result = await ai.get_move_async(engine)
        decision = result["decision"]
        
        # 4. Critical Validation: Check for Internal Fallback
        if hasattr(decision, 'reasoning') and decision.reasoning and decision.reasoning.startswith("⚠️ [SYSTEM ERROR]"):
            return (model_key, False, f"Fallback Triggered: {decision.reasoning[:100]}...")
        
        # 5. Validate Decision Structure
        if not hasattr(decision, 'column'):
            return (model_key, False, "Response missing 'column' attribute")
            
        if not isinstance(decision.column, int):
            return (model_key, False, f"Invalid column type: {type(decision.column)}")
        
        # 6. Validate Move Range
        if not (0 <= decision.column <= 6):
            return (model_key, False, f"Column out of bounds: {decision.column}")
        
        # 7. Validate Move is Legal on Current Board
        valid_moves = engine.get_valid_moves()
        if decision.column not in valid_moves:
            return (model_key, False, f"Illegal move: column {decision.column} not in valid moves {valid_moves}")
        
        # 8. Success - All validations passed
        reasoning_preview = (decision.reasoning[:30] + "...") if hasattr(decision, 'reasoning') and decision.reasoning else "N/A"
        return (model_key, True, f"Column: {decision.column}, Reasoning: {reasoning_preview}")
        
    except Exception as e:
        return (model_key, False, f"Exception: {str(e)[:80]}...")


async def main():
    """Main execution function with parallel processing."""
    print(f"🚀 Starting Parallel Verification (Limit: {CONCURRENCY_LIMIT} concurrent requests)...")
    print("-" * 80)
    print(f"{'MODEL ID':<30} | {'STATUS':<8} | {'DETAILS'}")
    print("-" * 80)

    # Semaphore to control concurrency and prevent rate limiting
    sem = asyncio.Semaphore(CONCURRENCY_LIMIT)

    async def protected_test(model_key: str) -> Tuple[str, bool, str]:
        """Wrapper function that respects the semaphore for rate limiting."""
        async with sem:
            return await test_model_generation(model_key)

    # Create tasks for all models
    model_keys = sorted(MODEL_PROVIDERS.keys())
    tasks = [protected_test(model_key) for model_key in model_keys]
    
    results = {}
    
    # Execute tasks and print results as they complete
    for coro in asyncio.as_completed(tasks):
        model, success, msg = await coro
        results[model] = success
        
        status_icon = "✅ PASS" if success else "❌ FAIL"
        # Truncate message if too long for table formatting
        clean_msg = (msg[:35] + '..') if len(msg) > 35 else msg
        
        print(f"{model:<30} | {status_icon:<8} | {clean_msg}")

    print("-" * 80)
    
    # Print Summary
    passed_count = sum(results.values())
    total = len(results)
    print(f"🏁 Summary: {passed_count}/{total} Passed")
    
    if passed_count < total:
        print("\n❌ Failed Models:")
        failed_models = [model for model, success in results.items() if not success]
        for model in failed_models:
            provider = MODEL_PROVIDERS.get(model, {}).get('provider', 'unknown')
            print(f"   • {model} [{provider}]")
        print(f"\n⚠️  {len(failed_models)} model(s) cannot generate valid structured outputs")
        print("   These models will fallback to random moves in actual gameplay.")
        sys.exit(1)
    else:
        print("✅ All models passed! Structured output generation is working correctly.")
        sys.exit(0)


if __name__ == "__main__":
    asyncio.run(main())
--- End of File: backend/scripts/verify_ai_moves.py ---

--- File: backend/Dockerfile ---
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies for PostgreSQL driver (psycopg2/asyncpg)
RUN apt-get update && apt-get install -y gcc libpq-dev && rm -rf /var/lib/apt/lists/*

# Install Python Dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy source code (Needed for the initial build context)
COPY . backend/

# Set Python path so imports work correctly
ENV PYTHONPATH=/app

# Start Command with Hot Reload enabled
# 1. Initialize DB tables
# 2. Start Uvicorn with --reload
CMD ["sh", "-c", "python -m backend.scripts.init_db && uvicorn backend.app.main:app --host 0.0.0.0 --port 8000 --reload"]
--- End of File: backend/Dockerfile ---

--- File: backend/migrate_analytics.py ---
import asyncio
import sys
import os
from sqlalchemy import text
from sqlalchemy.ext.asyncio import create_async_engine

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
from backend.app.core.database import get_database_url

async def migrate_schema():
    print("🔄 Connecting to database...")
    database_url = get_database_url()
    # Create a temporary engine just for this script
    engine = create_async_engine(database_url)

    async with engine.begin() as conn:
        print("🛠️  Adding new columns to 'elo_ratings' table...")
        
        # 1. Add total_moves
        await conn.execute(text("""
            ALTER TABLE elo_ratings 
            ADD COLUMN IF NOT EXISTS total_moves BIGINT DEFAULT 0;
        """))
        
        # 2. Add total_duration_seconds
        await conn.execute(text("""
            ALTER TABLE elo_ratings 
            ADD COLUMN IF NOT EXISTS total_duration_seconds FLOAT DEFAULT 0.0;
        """))

        # 3. Add total_input_tokens (Just in case)
        await conn.execute(text("""
            ALTER TABLE elo_ratings 
            ADD COLUMN IF NOT EXISTS total_input_tokens BIGINT DEFAULT 0;
        """))

        # 4. Add total_output_tokens (Just in case)
        await conn.execute(text("""
            ALTER TABLE elo_ratings 
            ADD COLUMN IF NOT EXISTS total_output_tokens BIGINT DEFAULT 0;
        """))

    print("✅ Schema update complete!")
    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(migrate_schema())
--- End of File: backend/migrate_analytics.py ---

--- File: backend/requirements.txt ---
fastapi==0.109.0
uvicorn[standard]==0.27.0
sqlalchemy==2.0.25
asyncpg==0.29.0
alembic==1.13.1
psycopg2-binary==2.9.9
langchain>=1.1.2
langchain-openai>=1.1.0
langchain-anthropic>=1.2.0
langchain-google-genai>=3.2.0
pydantic==2.9.0
python-dotenv==1.0.1
--- End of File: backend/requirements.txt ---

--- File: frontend/public/vite.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
--- End of File: frontend/public/vite.svg ---

--- File: frontend/src/api/client.js ---
import axios from 'axios';

const API_URL = 'http://localhost:8000';

export const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

export const getModels = async () => {
  const response = await apiClient.get('/models');
  return response.data;
};

export const createGame = async (player1, player2) => {
  const response = await apiClient.post('/games', {
    player_1: player1,
    player_2: player2,
  });
  return response.data;
};

export const getGame = async (gameId) => {
  const response = await apiClient.get(`/games/${gameId}`);
  return response.data;
};

export const getLeaderboard = async () => {
  const response = await apiClient.get('/stats/leaderboard');
  return response.data;
};

// --- NEW ---
export const getMatrix = async () => {
  const response = await apiClient.get('/stats/matrix');
  return response.data;
};
// -----------

export const getActiveGames = async () => {
  const response = await apiClient.get('/stats/active-games');
  return response.data;
};

export const getHistory = async (modelName) => {
  const url = modelName ? `/stats/history?model=${modelName}` : '/stats/history';
  const response = await apiClient.get(url);
  return response.data;
};

// Admin API functions
export const getAdminStatus = async () => {
  const response = await apiClient.get('/admin/status');
  return response.data;
};

export const resetDatabase = async () => {
  const response = await apiClient.delete('/admin/reset', {
    params: { confirmation: 'I-UNDERSTAND-THIS-DELETES-EVERYTHING' }
  });
  return response.data;
};

export const getGameHistory = async (skip = 0, limit = 50) => {
  const response = await apiClient.get('/games/history', { 
    params: { skip, limit } 
  });
  return response.data;
};

export const getPendingHumanGames = async () => {
  const response = await apiClient.get('/games/pending-human');
  return response.data; // Returns array of IDs, e.g., [1, 5, 8]
};

// --- TOURNAMENT API ---
export const createTournament = async (models, rounds, concurrency) => {
  const response = await apiClient.post('/tournament/create', {
    models,
    rounds,
    concurrency
  });
  return response.data;
};

export const startTournament = async (tournamentId) => {
  const response = await apiClient.post(`/tournament/${tournamentId}/start`);
  return response.data;
};

export const stopTournament = async (tournamentId) => {
  const response = await apiClient.post(`/tournament/${tournamentId}/stop`);
  return response.data;
};

export const getCurrentTournament = async () => {
  const response = await apiClient.get('/tournament/current');
  return response.data; // Returns null if no tournament exists
};

// --- NEW: Tournament Pause/Resume/Config API ---
export const pauseTournament = async (tournamentId) => {
  const response = await apiClient.post(`/tournament/${tournamentId}/pause`);
  return response.data;
};

export const resumeTournament = async (tournamentId) => {
  const response = await apiClient.post(`/tournament/${tournamentId}/resume`);
  return response.data;
};

export const updateTournamentConfig = async (tournamentId, concurrency) => {
  const response = await apiClient.patch(`/tournament/${tournamentId}/config`, {
    concurrency
  });
  return response.data;
};
// ----------------------
--- End of File: frontend/src/api/client.js ---

--- File: frontend/src/assets/react.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
--- End of File: frontend/src/assets/react.svg ---

--- File: frontend/src/components/GameBoard.jsx ---
import React from 'react';
import { clsx } from 'clsx';
import { motion } from 'framer-motion';

const GameBoard = ({ board, onColumnClick, currentTurn, isHumanTurn, winner }) => {
  if (!board) return null;

  return (
    <div className="flex flex-col items-center">
      {/* 
         Classic Blue Board 
         - Shadow added for depth
         - Border to separate from the light/dark background container
      */}
      <div className="bg-blue-600 dark:bg-blue-700 p-4 rounded-xl shadow-2xl inline-block border-4 border-blue-700 dark:border-blue-800 relative z-10">
        <div className="grid grid-rows-6 gap-3">
          {board.map((row, rowIndex) => (
            <div key={rowIndex} className="grid grid-cols-7 gap-3">
              {row.map((cell, colIndex) => (
                <div 
                  key={`${rowIndex}-${colIndex}`}
                  onClick={() => isHumanTurn && !winner && onColumnClick(colIndex)}
                  className={clsx(
                    "w-12 h-12 md:w-16 md:h-16 rounded-full flex items-center justify-center relative",
                    // The "Empty Hole" look: Dark blue background with inner shadow to look like a hole
                    "bg-blue-800 dark:bg-gray-900 shadow-[inset_0_4px_6px_rgba(0,0,0,0.4)]",
                    isHumanTurn && !winner ? "cursor-pointer hover:brightness-110" : "cursor-default"
                  )}
                >
                  {/* The Piece */}
                  {cell !== 0 && (
                    <motion.div
                      initial={{ y: -400, opacity: 0 }}
                      animate={{ y: 0, opacity: 1 }}
                      transition={{ type: "spring", stiffness: 250, damping: 25 }}
                      className={clsx(
                        "w-full h-full rounded-full shadow-md border-4",
                        // Red Piece
                        cell === 1 && "bg-red-500 border-red-600",
                        // Yellow Piece
                        cell === 2 && "bg-yellow-400 border-yellow-500"
                      )}
                    />
                  )}
                  
                  {/* Hover Guide (Phantom Piece) - Optional nice-to-have */}
                  {cell === 0 && isHumanTurn && !winner && (
                     <div className={clsx(
                       "absolute w-full h-full rounded-full opacity-0 hover:opacity-20 transition-opacity",
                       currentTurn === 1 ? "bg-red-500" : "bg-yellow-400"
                     )} />
                  )}
                </div>
              ))}
            </div>
          ))}
        </div>
      </div>
      
      {/* Column Indicators */}
      <div className="grid grid-cols-7 gap-3 mt-4 w-full px-4">
        {[0,1,2,3,4,5,6].map(col => (
           <div key={col} className="text-center">
             <span className="text-xs font-mono text-gray-400 dark:text-gray-500 select-none">
               {col + 1}
             </span>
           </div>
        ))}
      </div>
    </div>
  );
};

export default GameBoard;
--- End of File: frontend/src/components/GameBoard.jsx ---

--- File: frontend/src/components/Layout.jsx ---
import React from 'react';
import Navigation from './Navigation';

const Layout = ({ children }) => {
  return (
    <div className="min-h-screen transition-colors duration-300 ease-in-out bg-gray-50 dark:bg-gray-950 text-gray-900 dark:text-gray-100">
      <Navigation />
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {children}
      </main>
    </div>
  );
};

export default Layout;
--- End of File: frontend/src/components/Layout.jsx ---

--- File: frontend/src/components/MiniGameBoard.jsx ---
import React from 'react';
import { clsx } from 'clsx';

const MiniGameBoard = ({ board }) => {
  if (!board) return null;

  return (
    <div className="bg-blue-600 dark:bg-blue-700 p-2 rounded-lg shadow-inner border-2 border-blue-700 dark:border-blue-800">
      <div className="grid grid-rows-6 gap-1">
        {board.map((row, rowIndex) => (
          <div key={rowIndex} className="grid grid-cols-7 gap-1">
            {row.map((cell, colIndex) => (
              <div 
                key={`${rowIndex}-${colIndex}`}
                className={clsx(
                  "w-3 h-3 md:w-4 md:h-4 rounded-full flex items-center justify-center shadow-inner",
                  cell === 0 
                    ? "bg-blue-800 dark:bg-gray-900" 
                    : cell === 1 
                      ? "bg-red-500 shadow-sm" 
                      : "bg-yellow-400 shadow-sm"
                )}
              />
            ))}
          </div>
        ))}
      </div>
    </div>
  );
};

export default MiniGameBoard;
--- End of File: frontend/src/components/MiniGameBoard.jsx ---

--- File: frontend/src/components/Navigation.jsx ---
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { useTheme } from '../context/ThemeContext';
import { Sun, Moon, LayoutGrid, PlusCircle, History as HistoryIcon, Shield, BarChart2, Trophy } from 'lucide-react';

const Navigation = () => {
  const location = useLocation();
  const { theme, toggleTheme } = useTheme();

  const isActive = (path) => location.pathname === path;

  const NavLink = ({ to, icon: Icon, label }) => (
    <Link
      to={to}
      className={`flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-colors ${
        isActive(to)
          ? 'bg-gray-200 dark:bg-gray-800 text-gray-900 dark:text-white'
          : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800'
      }`}
    >
      <Icon size={18} />
      <span>{label}</span>
    </Link>
  );

  return (
    <nav className="sticky top-0 z-50 w-full border-b border-gray-200 dark:border-gray-800 bg-white/80 dark:bg-gray-900/80 backdrop-blur-md">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center h-16">
          {/* Logo */}
          <Link to="/" className="flex items-center gap-2">
            <div className="w-8 h-8 bg-brand-600 rounded-lg flex items-center justify-center text-white font-bold text-lg">
              C4
            </div>
            <span className="font-bold text-xl tracking-tight text-gray-900 dark:text-white hidden sm:block">
              Connect<span className="text-brand-600">AI</span>
            </span>
          </Link>

          {/* Links */}
          <div className="hidden md:flex items-center space-x-1">
            <NavLink to="/" icon={LayoutGrid} label="Overview" />
            <NavLink to="/tournament" icon={Trophy} label="Tournament" />
            <NavLink to="/statistics" icon={BarChart2} label="Statistics" />
            <NavLink to="/new" icon={PlusCircle} label="New Match" />
            <NavLink to="/history" icon={HistoryIcon} label="History" />
            <NavLink to="/admin" icon={Shield} label="Admin" />
          </div>

          {/* Theme Toggle */}
          <button
            onClick={toggleTheme}
            className="p-2 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors focus:outline-none"
            aria-label="Toggle Theme"
          >
            {theme === 'light' ? (
              <Moon size={20} className="text-gray-700" />
            ) : (
              <Sun size={20} className="text-yellow-400" />
            )}
          </button>
        </div>
      </div>
    </nav>
  );
};

export default Navigation;
--- End of File: frontend/src/components/Navigation.jsx ---

--- File: frontend/src/context/ThemeContext.jsx ---
import React, { createContext, useContext, useEffect, useState } from 'react';

const ThemeContext = createContext();

export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState(() => {
    // Check local storage or system preference
    if (localStorage.getItem('theme')) {
      return localStorage.getItem('theme');
    }
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  });

  useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove('light', 'dark');
    root.classList.add(theme);
    localStorage.setItem('theme', theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme((prev) => (prev === 'light' ? 'dark' : 'light'));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => useContext(ThemeContext);
--- End of File: frontend/src/context/ThemeContext.jsx ---

--- File: frontend/src/hooks/useGameSocket.js ---
import { useEffect, useState, useRef } from 'react';

const WS_URL = 'ws://localhost:8000';

export const useGameSocket = (gameId) => {
  const [gameState, setGameState] = useState(null);
  const [isThinking, setIsThinking] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const socketRef = useRef(null);

  useEffect(() => {
    // Clear previous game state immediately when gameId changes
    // This prevents "flickering" of the old game while loading the new one
    setGameState(null);
    setIsThinking(false);
    
    if (!gameId) return;

    const ws = new WebSocket(`${WS_URL}/games/${gameId}/ws`);
    socketRef.current = ws;

    ws.onopen = () => {
      console.log('Connected to Game WS');
      setIsConnected(true);
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      if (data.type === 'UPDATE') {
        setGameState({
          board: data.board,
          // --- FIX START: Match backend camelCase keys ---
          currentTurn: data.currentTurn, 
          winner: data.winner,
          status: data.status,
          lastMove: data.lastMove 
          // --- FIX END ---
        });
      } else if (data.type === 'THINKING_START') {
        setIsThinking(true);
      } else if (data.type === 'THINKING_END') {
        setIsThinking(false);
      }
    };

    ws.onclose = () => setIsConnected(false);

    return () => {
      if (socketRef.current) {
        socketRef.current.close();
      }
    };
  }, [gameId]);

  const sendMove = (colIndex) => {
    if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {
      socketRef.current.send(JSON.stringify({
        action: 'MOVE',
        column: colIndex
      }));
    }
  };

  return { gameState, isThinking, isConnected, sendMove };
};
--- End of File: frontend/src/hooks/useGameSocket.js ---

--- File: frontend/src/pages/Admin.jsx ---
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { AlertTriangle, Database, Trash2, RefreshCw, Shield } from 'lucide-react';
import { getAdminStatus, resetDatabase } from '../api/client';

const Admin = () => {
  const navigate = useNavigate();
  const [stats, setStats] = useState(null);
  const [isResetting, setIsResetting] = useState(false);
  const [confirmText, setConfirmText] = useState('');
  const [showModal, setShowModal] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchStats();
  }, []);

  const fetchStats = async () => {
    try {
      const data = await getAdminStatus();
      setStats(data);
    } catch (error) {
      console.error('Failed to fetch admin stats:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleResetDatabase = async () => {
    if (confirmText !== 'DELETE') {
      alert('You must type "DELETE" to confirm');
      return;
    }

    setIsResetting(true);
    try {
      await resetDatabase();
      alert('Database successfully reset!');
      setShowModal(false);
      setConfirmText('');
      await fetchStats(); // Refresh stats
      // Optionally redirect to dashboard
      navigate('/');
    } catch (error) {
      const errorMessage = error.response?.data?.detail || error.message || 'Network error';
      alert(`Reset failed: ${errorMessage}`);
      console.error('Reset error:', error);
    } finally {
      setIsResetting(false);
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-[400px]">
        <RefreshCw className="animate-spin text-blue-500" size={24} />
        <span className="ml-2 text-slate-400">Loading admin panel...</span>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto space-y-6">
      {/* Header */}
      <div className="flex items-center gap-3">
        <Shield className="text-brand-600 dark:text-brand-500" size={32} />
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Administration</h1>
      </div>

      {/* Database Statistics */}
      <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 shadow-sm overflow-hidden">
        <div className="px-6 py-4 border-b border-gray-100 dark:border-gray-800 flex items-center gap-2">
          <div className="p-2 bg-gray-100 dark:bg-gray-800 rounded-lg text-brand-600 dark:text-brand-500">
            <Database size={18} />
          </div>
          <h2 className="font-semibold text-gray-900 dark:text-white">Database Statistics</h2>
        </div>
        
        <div className="p-6">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <div className="text-2xl font-bold text-brand-600 dark:text-brand-400">{stats?.games || 0}</div>
              <div className="text-sm text-gray-500 dark:text-gray-400">Total Games</div>
            </div>
            <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <div className="text-2xl font-bold text-green-600 dark:text-green-400">{stats?.elo_ratings || 0}</div>
              <div className="text-sm text-gray-500 dark:text-gray-400">ELO Ratings</div>
            </div>
            <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <div className="text-2xl font-bold text-purple-600 dark:text-purple-400">{stats?.elo_history || 0}</div>
              <div className="text-sm text-gray-500 dark:text-gray-400">ELO History Records</div>
            </div>
          </div>
        </div>
      </div>

      {/* Danger Zone */}
      <div className="bg-white dark:bg-gray-900 rounded-xl border border-red-200 dark:border-red-800 shadow-sm overflow-hidden">
        <div className="px-6 py-4 border-b border-red-100 dark:border-red-800 flex items-center gap-2">
          <div className="p-2 bg-red-100 dark:bg-red-900/20 rounded-lg text-red-600 dark:text-red-400">
            <AlertTriangle size={18} />
          </div>
          <h2 className="font-semibold text-red-600 dark:text-red-400">Danger Zone</h2>
        </div>
        
        <div className="p-6">
          <div className="bg-red-50 dark:bg-red-900/20 p-4 rounded-lg mb-4 border border-red-200 dark:border-red-800">
            <p className="text-red-700 dark:text-red-300 text-sm mb-2">
              ⚠️ <strong>Warning:</strong> This action cannot be undone!
            </p>
            <p className="text-gray-600 dark:text-gray-300 text-sm">
              This will permanently delete all games, ELO ratings, and match history from the database.
            </p>
          </div>

          <button
            onClick={() => setShowModal(true)}
            className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-medium transition-colors flex items-center gap-2"
          >
            <Trash2 size={18} />
            Reset Database
          </button>
        </div>
      </div>

      {/* Confirmation Modal */}
      {showModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl">
            <div className="flex items-center gap-2 mb-4">
              <AlertTriangle className="text-red-500" size={24} />
              <h3 className="text-xl font-semibold text-gray-900 dark:text-white">Confirm Database Reset</h3>
            </div>

            <div className="mb-4">
              <p className="text-gray-600 dark:text-gray-300 mb-2">
                Are you absolutely sure? This will permanently delete:
              </p>
              <ul className="text-sm text-gray-500 dark:text-gray-400 space-y-1">
                <li>• {stats?.games || 0} games</li>
                <li>• {stats?.elo_ratings || 0} ELO ratings</li>
                <li>• {stats?.elo_history || 0} history records</li>
              </ul>
            </div>

            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                Type "DELETE" to confirm:
              </label>
              <input
                type="text"
                value={confirmText}
                onChange={(e) => setConfirmText(e.target.value)}
                className="w-full bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-2 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-red-500"
                placeholder="Type DELETE here"
              />
            </div>

            <div className="flex gap-3">
              <button
                onClick={() => {
                  setShowModal(false);
                  setConfirmText('');
                }}
                className="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 rounded-lg transition-colors"
                disabled={isResetting}
              >
                Cancel
              </button>
              <button
                onClick={handleResetDatabase}
                disabled={isResetting || confirmText !== 'DELETE'}
                className="flex-1 bg-red-600 hover:bg-red-700 disabled:bg-red-800 disabled:cursor-not-allowed text-white py-2 rounded-lg transition-colors flex items-center justify-center gap-2"
              >
                {isResetting ? (
                  <>
                    <RefreshCw className="animate-spin" size={16} />
                    Resetting...
                  </>
                ) : (
                  <>
                    <Trash2 size={16} />
                    Reset Database
                  </>
                )}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default Admin;
--- End of File: frontend/src/pages/Admin.jsx ---

--- File: frontend/src/pages/Arena.jsx ---
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useGameSocket } from '../hooks/useGameSocket';
import GameBoard from '../components/GameBoard';
import { getGame, getPendingHumanGames } from '../api/client';
import { Brain, Cpu, User, Play, Pause, SkipBack, SkipForward, Eye, AlertCircle, ChevronLeft, ChevronRight, Gamepad2 } from 'lucide-react';

const Arena = () => {
  const { id } = useParams();
  const gameId = parseInt(id);
  const navigate = useNavigate(); // Hook for navigation
  const [meta, setMeta] = useState(null);
  const [replayStep, setReplayStep] = useState(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const { gameState, isThinking, isConnected, sendMove } = useGameSocket(gameId);
  
  // NEW: State for actionable games
  const [actionableGames, setActionableGames] = useState([]);

  useEffect(() => {
    getGame(gameId).then((game) => {
      setMeta(game);
      // If game is completed, enter replay mode
      if (game.status === 'COMPLETED' || game.status === 'DRAW') {
        setReplayStep(game.history ? game.history.length - 1 : 0);
      }
    }).catch(console.error);
  }, [gameId]);

  // NEW: Watch for Live Game Completion to trigger Replay Mode
  useEffect(() => {
    if (gameState && (gameState.status === 'COMPLETED' || gameState.status === 'DRAW')) {
      // Game just finished live. Fetch full history to enable replay.
      getGame(gameId).then((fullGame) => {
        setMeta(fullGame); // This updates status and populates history
        setReplayStep(fullGame.history.length - 1); // Jump to end
      }).catch(console.error);
    }
  }, [gameState?.status, gameId]);

  // Auto-play replay
  useEffect(() => {
    if (isPlaying && meta?.history && replayStep < meta.history.length - 1) {
      const timer = setTimeout(() => {
        setReplayStep(prev => prev + 1);
      }, 1500);
      return () => clearTimeout(timer);
    } else {
      setIsPlaying(false);
    }
  }, [isPlaying, replayStep, meta?.history]);

  // NEW: Fetch actionable games list
  const fetchActionableGames = async () => {
    try {
      const ids = await getPendingHumanGames();
      console.log("Queue from API:", ids); // <--- Add this debug log
      setActionableGames(ids);
    } catch (error) {
      console.error("Failed to fetch pending games", error);
    }
  };

  // --- FIX START: Added status and winner to dependencies ---
  // Initial fetch + fetch whenever game state updates (e.g. after I move, win, or lose)
  useEffect(() => {
    fetchActionableGames();
  }, [gameState?.currentTurn, gameState?.status, gameState?.winner, gameId]);
  // --- FIX END ---

  // Helper to calculate Next/Prev
  const handleNavigate = (direction) => {
    if (actionableGames.length === 0) return;

    const currentIndex = actionableGames.indexOf(gameId);
    let nextId;

    if (currentIndex === -1) {
      // If current game is not in the list (e.g. I just played), go to the first one
      nextId = actionableGames[0];
    } else {
      // Circular navigation
      if (direction === 'next') {
        const nextIndex = (currentIndex + 1) % actionableGames.length;
        nextId = actionableGames[nextIndex];
      } else {
        const prevIndex = (currentIndex - 1 + actionableGames.length) % actionableGames.length;
        nextId = actionableGames[prevIndex];
      }
    }
    
    // Only navigate if it's a different game
    if (nextId !== gameId) {
      navigate(`/game/${nextId}`);
    }
  };

  // Helper function to reconstruct board at specific step
  const reconstructBoard = (history, step) => {
    // Initialize empty 6x7 board
    const board = Array(6).fill().map(() => Array(7).fill(0));
    
    // Replay moves up to step
    for (let i = 0; i <= step && i < history.length; i++) {
      const move = history[i];
      const col = move.column;
      
      // Find the lowest empty row in this column
      for (let row = 5; row >= 0; row--) {
        if (board[row][col] === 0) {
          board[row][col] = move.player;
          break;
        }
      }
    }
    
    return board;
  };

  const isSpectatorMode = meta?.player_1_type !== 'human' && meta?.player_2_type !== 'human';
  const isReplayMode = meta?.status === 'COMPLETED' || meta?.status === 'DRAW';
  const isLiveMode = !isReplayMode && isConnected;

  const handleColumnClick = (colIndex) => {
    // Disable interactions in replay mode or spectator mode
    if (isReplayMode || isSpectatorMode) return;
    
    if (gameState && !gameState.winner && !isThinking) {
      sendMove(colIndex);
    }
  };

  if (!gameState && !meta) return <div className="text-center p-10 text-gray-500">Connecting to Arena...</div>;

  const p1Name = meta?.player_1_type || "Player 1";
  const p2Name = meta?.player_2_type || "Player 2";
  
  // Use replay state if in replay mode
  let displayBoard, currentTurn, status, winner, lastMove;
  
  if (isReplayMode && meta?.history) {
    displayBoard = reconstructBoard(meta.history, replayStep);
    currentTurn = replayStep < meta.history.length ? meta.history[replayStep]?.player : 1;
    status = meta.status;
    winner = meta.winner;
    lastMove = replayStep >= 0 ? meta.history[replayStep] : null;
  } else {
    displayBoard = gameState?.board;
    currentTurn = gameState?.currentTurn || 1;
    status = gameState?.status || "LOADING";
    winner = gameState?.winner;
    lastMove = gameState?.lastMove;
  }

  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
      {/* Sidebar */}
      <div className="lg:col-span-1 space-y-6">
        
        {/* --- NEW: Quick Navigator Card --- */}
        {actionableGames.length > 0 && (
          <div className="bg-brand-600 dark:bg-brand-900 rounded-xl p-4 text-white shadow-lg border border-brand-500">
            <div className="flex items-center gap-2 mb-3 opacity-90">
               <Gamepad2 size={18} />
               <span className="text-sm font-bold uppercase tracking-wider">Your Turn Queue</span>
            </div>
            
            <div className="flex items-center justify-between gap-2">
              <button 
                onClick={() => handleNavigate('prev')}
                className="p-2 bg-white/10 hover:bg-white/20 rounded-lg transition"
                title="Previous Active Game"
              >
                <ChevronLeft size={20} />
              </button>
              
              <div className="text-center">
                 <div className="text-2xl font-bold">{actionableGames.length}</div>
                 <div className="text-xs opacity-75">Games Waiting</div>
              </div>

              <button 
                onClick={() => handleNavigate('next')}
                className="p-2 bg-white/10 hover:bg-white/20 rounded-lg transition"
                title="Next Active Game"
              >
                <ChevronRight size={20} />
              </button>
            </div>
            
            {!actionableGames.includes(gameId) && (
               <div className="mt-3 text-center">
                 <button 
                   onClick={() => navigate(`/game/${actionableGames[0]}`)}
                   className="text-xs bg-white text-brand-600 px-3 py-1 rounded-full font-bold shadow-sm hover:bg-gray-100"
                 >
                   Jump to Game #{actionableGames[0]}
                 </button>
               </div>
            )}
          </div>
        )}
        {/* ----------------------------------- */}
        
        {/* Match Info Card */}
        <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 p-6 shadow-sm">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-lg font-bold text-gray-900 dark:text-white">Match #{gameId}</h2>
            <div className="flex gap-2">
              {isSpectatorMode && isLiveMode && (
                <span className="px-2 py-1 rounded-md text-xs font-medium bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300 flex items-center gap-1">
                  <Eye size={12} /> Spectating
                </span>
              )}
              {isReplayMode && (
                <span className="px-2 py-1 rounded-md text-xs font-medium bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300">
                  Replay
                </span>
              )}
              {isLiveMode && (
                <span className={`px-2 py-1 rounded-md text-xs font-medium ${isConnected ? 'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300' : 'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300'}`}>
                  {isConnected ? 'LIVE' : 'OFFLINE'}
                </span>
              )}
            </div>
          </div>

          {/* Players */}
          <div className="space-y-3">
            <div className={`p-4 rounded-lg border transition-all ${currentTurn === 1 ? 'bg-red-50 border-red-200 dark:bg-red-900/10 dark:border-red-900/50 shadow-sm' : 'bg-gray-50 border-gray-100 dark:bg-gray-800 dark:border-gray-700 opacity-60'}`}>
              <div className="flex items-center gap-3">
                <div className="w-3 h-3 rounded-full bg-red-500 shadow-sm"></div>
                <div className="font-medium text-gray-900 dark:text-white flex items-center gap-2">
                  {p1Name === 'human' ? <User size={16}/> : <Cpu size={16}/>} {p1Name}
                </div>
              </div>
            </div>
            <div className={`p-4 rounded-lg border transition-all ${currentTurn === 2 ? 'bg-yellow-50 border-yellow-200 dark:bg-yellow-900/10 dark:border-yellow-900/50 shadow-sm' : 'bg-gray-50 border-gray-100 dark:bg-gray-800 dark:border-gray-700 opacity-60'}`}>
              <div className="flex items-center gap-3">
                <div className="w-3 h-3 rounded-full bg-yellow-400 shadow-sm"></div>
                <div className="font-medium text-gray-900 dark:text-white flex items-center gap-2">
                  {p2Name === 'human' ? <User size={16}/> : <Cpu size={16}/>} {p2Name}
                </div>
              </div>
            </div>
          </div>

          <div className="mt-6 pt-6 border-t border-gray-100 dark:border-gray-800 text-center">
             {winner ? (
                <div className="p-3 bg-green-50 dark:bg-green-900/20 text-green-700 dark:text-green-400 font-bold rounded-lg border border-green-100 dark:border-green-900/30">
                  🏆 {winner === 1 ? p1Name : p2Name} Wins!
                </div>
             ) : (
                <div className="text-gray-500 dark:text-gray-400 text-sm">
                  Status: <span className="text-gray-900 dark:text-white font-medium">{status}</span>
                </div>
             )}
          </div>
        </div>

        {/* AI Reasoning Card */}
        {lastMove?.reasoning && (
          <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 p-6 shadow-sm flex flex-col h-[300px]">
            <div className="flex items-center gap-2 mb-4 text-brand-600 dark:text-brand-400">
              <Brain size={20} /><h3 className="font-bold">AI Thought Process</h3>
            </div>
            
            <div className={`flex-1 p-4 rounded-lg text-sm leading-relaxed border overflow-y-auto ${
              lastMove.reasoning.startsWith('⚠️') 
                ? 'bg-red-50 border-red-100 text-red-700 dark:bg-red-900/20 dark:border-red-900/50 dark:text-red-300' 
                : 'bg-gray-50 border-gray-100 text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-300'
            }`}>
              <p className="whitespace-pre-wrap">{lastMove.reasoning}</p>
            </div>
            
            <div className="mt-3 text-right text-xs text-gray-400 font-mono">
              Tokens: {lastMove.input_tokens || 0} in / {lastMove.output_tokens || 0} out
            </div>
          </div>
        )}

        {/* Replay Controls */}
        {isReplayMode && meta?.history && (
          <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 p-6 shadow-sm">
            <div className="flex items-center gap-2 mb-4 text-purple-600 dark:text-purple-400">
              <Play size={20} />
              <h3 className="font-bold">Replay Controls</h3>
            </div>
            
            <div className="space-y-6">
              <div className="flex items-center justify-center gap-4">
                <button onClick={() => setReplayStep(0)} disabled={replayStep === 0} className="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-full transition disabled:opacity-30">
                  <SkipBack size={20} className="text-gray-600 dark:text-gray-300" />
                </button>
                
                <button onClick={() => setIsPlaying(!isPlaying)} disabled={replayStep >= meta.history.length - 1} className="p-4 bg-purple-600 hover:bg-purple-700 text-white rounded-full shadow-md transition disabled:opacity-50 disabled:cursor-not-allowed">
                  {isPlaying ? <Pause size={24} /> : <Play size={24} className="ml-1" />}
                </button>
                
                <button onClick={() => setReplayStep(meta.history.length - 1)} disabled={replayStep >= meta.history.length - 1} className="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-full transition disabled:opacity-30">
                  <SkipForward size={20} className="text-gray-600 dark:text-gray-300" />
                </button>
              </div>
              
              <div className="space-y-2">
                <input
                  type="range"
                  min="0"
                  max={meta.history.length - 1}
                  value={replayStep}
                  onChange={(e) => setReplayStep(parseInt(e.target.value))}
                  className="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer accent-purple-600"
                />
                <div className="flex justify-between text-xs text-gray-500 font-medium">
                  <span>Start</span>
                  <span>Move {replayStep + 1} / {meta.history.length}</span>
                  <span>End</span>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Game Board Area */}
      <div className="lg:col-span-2">
        <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 p-8 flex flex-col items-center relative min-h-[600px] justify-center shadow-sm">
           
           {/* Overlays */}
           {isThinking && isLiveMode && (
             <div className="absolute top-6 right-6 z-20 bg-white/90 dark:bg-gray-800/90 backdrop-blur text-yellow-600 dark:text-yellow-400 px-4 py-2 rounded-full flex items-center gap-2 border border-yellow-200 dark:border-yellow-900/50 shadow-lg">
               <div className="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
               <span className="text-sm font-bold">AI Thinking...</span>
             </div>
           )}
           
           {displayBoard ? (
             <GameBoard 
                board={displayBoard} 
                onColumnClick={handleColumnClick} 
                currentTurn={currentTurn} 
                isHumanTurn={!isSpectatorMode && !isReplayMode} 
                winner={winner} 
             />
           ) : (
             <div className="text-gray-400 flex flex-col items-center gap-3">
                <div className="w-8 h-8 border-4 border-gray-300 border-t-brand-600 rounded-full animate-spin"></div>
                <p>Loading Game State...</p>
             </div>
           )}
        </div>
      </div>
    </div>
  );
};

export default Arena;
--- End of File: frontend/src/pages/Arena.jsx ---

--- File: frontend/src/pages/Dashboard.jsx ---
import React, { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import { getLeaderboard, getActiveGames } from '../api/client';
import { Trophy, Activity, ArrowRight, Hash } from 'lucide-react';

const Dashboard = () => {
  const [leaderboard, setLeaderboard] = useState([]);
  const [activeGames, setActiveGames] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [lbData, gamesData] = await Promise.all([
          getLeaderboard(),
          getActiveGames()
        ]);
        setLeaderboard(lbData);
        setActiveGames(gamesData);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
    const interval = setInterval(fetchData, 5000);
    return () => clearInterval(interval);
  }, []);

  const Card = ({ title, icon: Icon, children, className = "" }) => (
    <div className={`bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 shadow-sm overflow-hidden flex flex-col ${className}`}>
      <div className="px-6 py-4 border-b border-gray-100 dark:border-gray-800 flex items-center justify-between shrink-0">
        <div className="flex items-center gap-2">
          <div className="p-2 bg-gray-100 dark:bg-gray-800 rounded-lg text-brand-600 dark:text-brand-500">
            <Icon size={18} />
          </div>
          <h2 className="font-semibold text-gray-900 dark:text-white">{title}</h2>
        </div>
      </div>
      {children}
    </div>
  );

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">System Overview</h1>
          <p className="text-gray-500 dark:text-gray-400 text-sm mt-1">Real-time benchmarks and live games.</p>
        </div>
        <Link
          to="/new"
          className="inline-flex justify-center items-center px-4 py-2 bg-brand-600 hover:bg-brand-700 text-white text-sm font-medium rounded-lg transition-colors shadow-sm"
        >
          Start New Match
        </Link>
      </div>

      {/* 
         FIX: Removed 'items-start'. 
         This restores default 'stretch' behavior so both cards in the row will match the height of the tallest one.
      */}
      <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
        {/* Expanded Leaderboard */}
        <Card title="Model Performance" icon={Trophy} className="lg:col-span-3">
          <div className="overflow-x-auto">
            <table className="w-full text-sm text-left">
              <thead className="bg-gray-50 dark:bg-gray-800/50 text-gray-500 dark:text-gray-400 uppercase text-xs">
                <tr>
                  <th className="px-6 py-3 font-medium">Rank</th>
                  <th className="px-6 py-3 font-medium">Model</th>
                  <th className="px-6 py-3 font-medium">ELO</th>
                  <th className="px-6 py-3 font-medium text-right">Win Rate</th>
                  <th className="px-6 py-3 font-medium text-right">Games Played</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-100 dark:divide-gray-800">
                {leaderboard.map((entry, index) => {
                  const total = entry.wins + entry.losses + entry.draws;
                  const winRate = total > 0 ? ((entry.wins / total) * 100).toFixed(1) : 0;
                  return (
                    <tr key={entry.model_name} className="hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors">
                      <td className="px-6 py-4 font-mono text-gray-400">#{index + 1}</td>
                      <td className="px-6 py-4 font-medium text-gray-900 dark:text-white">{entry.model_name}</td>
                      <td className="px-6 py-4 font-mono text-brand-600 dark:text-brand-400">{Math.round(entry.rating)}</td>
                      <td className="px-6 py-4 text-right">
                        <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${
                          winRate >= 50 
                            ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400' 
                            : 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-400'
                        }`}>
                          {winRate}%
                        </span>
                      </td>
                      <td className="px-6 py-4 text-right text-gray-600 dark:text-gray-300">
                        {entry.matches_played}
                      </td>
                    </tr>
                  );
                })}
                {leaderboard.length === 0 && (
                  <tr><td colSpan="5" className="px-6 py-8 text-center text-gray-500">No data available</td></tr>
                )}
              </tbody>
            </table>
          </div>
        </Card>

        {/* Active Matches (Sidebar) */}
        <Card title="Live Activity" icon={Activity} className="lg:col-span-1 h-full min-h-[500px]">
          <div className="flex-1 min-h-0 overflow-y-auto divide-y divide-gray-100 dark:divide-gray-800">
            {activeGames.length === 0 ? (
              <div className="p-8 text-center text-gray-500 text-sm flex flex-col items-center justify-center h-full">
                No matches in progress.
              </div>
            ) : (
              activeGames.map((game) => (
                <Link
                  key={game.id}
                  to={`/game/${game.id}`}
                  className="block p-4 hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors group"
                >
                  <div className="flex justify-between items-center mb-2">
                    <span className="text-xs font-mono text-gray-400">#{game.id}</span>
                    <div className="flex gap-1.5">
                       <span className="flex items-center gap-1 text-[10px] font-bold text-gray-500 dark:text-gray-400 bg-gray-100 dark:bg-gray-800 px-1.5 py-0.5 rounded-full">
                         <Hash size={9} /> {game.move_count}
                       </span>
                       <span className="flex items-center gap-1 text-[10px] font-bold tracking-wider text-brand-600 dark:text-brand-400 uppercase bg-brand-50 dark:bg-brand-900/20 px-1.5 py-0.5 rounded-full">
                        Live
                       </span>
                    </div>
                  </div>
                  <div className="space-y-2 text-sm">
                    <div className="flex items-center justify-between">
                       <span className="text-gray-900 dark:text-gray-200 truncate text-xs font-medium">{game.player_1}</span>
                       <span className={`w-2 h-2 rounded-full bg-red-400 shadow-sm`}></span>
                    </div>
                    <div className="flex items-center justify-between">
                       <span className="text-gray-900 dark:text-gray-200 truncate text-xs font-medium">{game.player_2}</span>
                       <span className={`w-2 h-2 rounded-full bg-yellow-400 shadow-sm`}></span>
                    </div>
                  </div>
                  <div className="mt-3 flex items-center justify-end gap-1 text-[11px] text-brand-600 dark:text-brand-400 font-medium opacity-0 group-hover:opacity-100 transition-opacity">
                    Watch <ArrowRight size={12} />
                  </div>
                </Link>
              ))
            )}
          </div>
        </Card>
      </div>
    </div>
  );
};

export default Dashboard;
--- End of File: frontend/src/pages/Dashboard.jsx ---

--- File: frontend/src/pages/History.jsx ---
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { History as HistoryIcon, User, Cpu, Trophy, Play, Calendar, Hash, RefreshCw, Clock, Zap } from 'lucide-react';
import { getGameHistory } from '../api/client';

const History = () => {
  const [games, setGames] = useState([]);
  const [loading, setLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(0);
  const [hasMore, setHasMore] = useState(true);

  const GAMES_PER_PAGE = 50;

  useEffect(() => {
    // Initial load only
    loadGames(0, true);
  }, []);

  const loadGames = async (page, isReset) => {
    setLoading(true);
    try {
      const skip = page * GAMES_PER_PAGE;
      const data = await getGameHistory(skip, GAMES_PER_PAGE);
      
      if (isReset) {
        setGames(data);
      } else {
        setGames(prev => [...prev, ...data]);
      }
      setHasMore(data.length === GAMES_PER_PAGE);
    } catch (e) {
      console.error('Failed to fetch game history:', e);
    } finally {
      setLoading(false);
    }
  };

  const onRefresh = () => {
    setCurrentPage(0);
    loadGames(0, true);
  };

  const onLoadMore = () => {
    const nextPage = currentPage + 1;
    setCurrentPage(nextPage);
    loadGames(nextPage, false);
  };

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  const getPlayerIcon = (playerType) => {
    return playerType === 'human' ? <User size={16} /> : <Cpu size={16} />;
  };

  const getResultDisplay = (game) => {
    if (game.status === 'DRAW') {
      return <span className="text-yellow-400">Draw</span>;
    }
    
    if (game.winner === 1) {
      return <span className="text-green-400">P1 Win</span>;
    } else if (game.winner === 2) {
      return <span className="text-blue-400">P2 Win</span>;
    }
    
    return <span className="text-slate-400">Unknown</span>;
  };

  const getPlayerName = (playerType) => {
    return playerType === 'human' ? 'Human' : playerType;
  };

  // Helper to sum up stats from history array
  const getGameStats = (history) => {
    if (!history) return { p1Time: 0, p2Time: 0, p1Tokens: 0, p2Tokens: 0 };
    
    let p1Time = 0, p2Time = 0, p1Tokens = 0, p2Tokens = 0;
    
    history.forEach(move => {
      if (move.player === 1) {
        p1Time += move.duration || 0;
        p1Tokens += move.output_tokens || 0;
      } else {
        p2Time += move.duration || 0;
        p2Tokens += move.output_tokens || 0;
      }
    });
    
    return { 
      p1Time: p1Time.toFixed(1), 
      p2Time: p2Time.toFixed(1), 
      p1Tokens, 
      p2Tokens 
    };
  };

  if (loading && games.length === 0) {
    return (
      <div className="flex justify-center items-center min-h-[400px]">
        <div className="text-slate-400">Loading game history...</div>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <HistoryIcon className="text-brand-600 dark:text-brand-500" size={32} />
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Game History</h1>
        </div>
        
        {/* Refresh Button */}
        <button 
          onClick={onRefresh}
          className="p-2 bg-white dark:bg-gray-900 hover:bg-gray-50 dark:hover:bg-gray-800 text-gray-500 dark:text-gray-400 rounded-lg border border-gray-200 dark:border-gray-700 transition-colors"
          title="Refresh List"
        >
          <RefreshCw size={20} className={loading ? "animate-spin" : ""} />
        </button>
      </div>

      {games.length === 0 ? (
        <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 p-8 text-center">
          <HistoryIcon className="mx-auto text-gray-400 dark:text-gray-500 mb-4" size={48} />
          <h2 className="text-xl text-gray-700 dark:text-gray-300 mb-2">No Games Found</h2>
          <p className="text-gray-500 dark:text-gray-400">No completed games to display yet.</p>
          <Link 
            to="/new" 
            className="mt-4 inline-block bg-brand-600 hover:bg-brand-700 text-white px-4 py-2 rounded-lg transition-colors"
          >
            Start a New Game
          </Link>
        </div>
      ) : (
        <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 overflow-hidden shadow-sm">
          {/* Table */}
          <div className="overflow-x-auto">
            <table className="w-full">
              <thead className="bg-gray-50 dark:bg-gray-800 text-gray-500 dark:text-gray-400 text-xs uppercase">
                <tr>
                  <th className="px-4 py-3 text-left">Date</th>
                  <th className="px-4 py-3 text-left">ID</th>
                  <th className="px-4 py-3 text-left">Player 1 (Red)</th>
                  <th className="px-4 py-3 text-left">Player 2 (Yel)</th>
                  <th className="px-4 py-3 text-center">Result</th>
                  <th className="px-4 py-3 text-right">P1 Stats (Time / Tok)</th>
                  <th className="px-4 py-3 text-right">P2 Stats (Time / Tok)</th>
                  <th className="px-4 py-3 text-center">Action</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-100 dark:divide-gray-800 text-sm">
                {games.map((game) => {
                  const stats = getGameStats(game.history);
                  return (
                    <tr key={game.id} className="hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors">
                      <td className="px-4 py-3 text-gray-500">{formatDate(game.created_at)}</td>
                      <td className="px-4 py-3 font-mono text-brand-600">#{game.id}</td>
                      
                      <td className="px-4 py-3">
                        <div className="flex items-center gap-2">
                          {getPlayerIcon(game.player_1_type)}
                          <span className={game.winner === 1 ? 'font-bold text-gray-900 dark:text-white' : 'text-gray-600 dark:text-gray-400'}>
                            {game.player_1_type}
                          </span>
                        </div>
                      </td>
                      
                      <td className="px-4 py-3">
                        <div className="flex items-center gap-2">
                          {getPlayerIcon(game.player_2_type)}
                          <span className={game.winner === 2 ? 'font-bold text-gray-900 dark:text-white' : 'text-gray-600 dark:text-gray-400'}>
                            {game.player_2_type}
                          </span>
                        </div>
                      </td>

                      <td className="px-4 py-3 text-center font-bold">
                        {game.status === 'DRAW' ? (
                          <span className="text-yellow-500">Draw</span>
                        ) : game.winner === 1 ? (
                          <span className="text-green-500">P1 Win</span>
                        ) : (
                          <span className="text-blue-500">P2 Win</span>
                        )}
                      </td>

                      {/* Stats Columns */}
                      <td className="px-4 py-3 text-right font-mono text-xs text-gray-500">
                         {stats.p1Time}s / {stats.p1Tokens}T
                      </td>
                      <td className="px-4 py-3 text-right font-mono text-xs text-gray-500">
                         {stats.p2Time}s / {stats.p2Tokens}T
                      </td>

                      <td className="px-4 py-3 text-center">
                        <Link to={`/game/${game.id}`} className="text-brand-600 hover:underline text-xs font-bold">
                          View
                        </Link>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>

          {/* Pagination */}
          {hasMore && (
            <div className="border-t border-gray-100 dark:border-gray-800 p-4 text-center">
              <button
                onClick={onLoadMore}
                disabled={loading}
                className="bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 disabled:bg-gray-50 dark:disabled:bg-gray-900 text-gray-700 dark:text-gray-200 disabled:text-gray-400 dark:disabled:text-gray-500 px-4 py-2 rounded-lg transition-colors disabled:cursor-not-allowed"
              >
                {loading ? 'Loading...' : 'Load More'}
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default History;
--- End of File: frontend/src/pages/History.jsx ---

--- File: frontend/src/pages/NewGame.jsx ---
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { createGame, getModels } from '../api/client';
import { Bot, User, Sword, Shuffle } from 'lucide-react';

const NewGame = () => {
  const navigate = useNavigate();
  const [models, setModels] = useState([]); // Dynamic List
  const [loadingModels, setLoadingModels] = useState(true);
  
  // Form State
  const [p1Type, setP1Type] = useState('human');
  const [p1Model, setP1Model] = useState('');
  const [p2Type, setP2Type] = useState('ai');
  const [p2Model, setP2Model] = useState('');
  
  const [loading, setLoading] = useState(false);

  // 1. Fetch Models on Mount
  useEffect(() => {
    const fetchModels = async () => {
      try {
        const data = await getModels();
        setModels(data);
        if (data.length > 0) {
          setP1Model(data[0].id);
          setP2Model(data[0].id);
        }
      } catch (error) {
        console.error("Failed to load models", error);
      } finally {
        setLoadingModels(false);
      }
    };
    fetchModels();
  }, []);

  const handleRandomize = () => {
    if (models.length < 2) return;

    // 1. Pick first random model
    const randomIndex1 = Math.floor(Math.random() * models.length);
    const model1 = models[randomIndex1];

    // 2. Pick second random model (ensure it's different)
    let model2;
    do {
      const randomIndex2 = Math.floor(Math.random() * models.length);
      model2 = models[randomIndex2];
    } while (model2.id === model1.id);

    // 3. Update all states
    setP1Type('ai');
    setP2Type('ai');
    setP1Model(model1.id);
    setP2Model(model2.id);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    try {
      const player1 = p1Type === 'human' ? 'human' : p1Model;
      const player2 = p2Type === 'human' ? 'human' : p2Model;
      
      const game = await createGame(player1, player2);
      navigate(`/game/${game.id}`);
    } catch (error) {
      console.error(error);
      alert('Failed to start game');
    } finally {
      setLoading(false);
    }
  };

  // 2. Dynamic Select Component
  const ModelSelect = ({ value, onChange }) => {
    if (loadingModels) return <div className="text-gray-500 dark:text-gray-400 text-sm">Loading models...</div>;
    
    // Group by Provider
    const groups = models.reduce((acc, model) => {
      const p = model.provider.charAt(0).toUpperCase() + model.provider.slice(1);
      if (!acc[p]) acc[p] = [];
      acc[p].push(model);
      return acc;
    }, {});

    return (
      <select 
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="w-full bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg px-4 py-3 text-gray-900 dark:text-white focus:ring-2 focus:ring-brand-500 outline-none"
      >
        {Object.keys(groups).map(provider => (
          <optgroup key={provider} label={provider}>
            {groups[provider].map(m => (
              <option key={m.id} value={m.id}>{m.label}</option>
            ))}
          </optgroup>
        ))}
      </select>
    );
  };

  return (
    <div className="max-w-2xl mx-auto">
      <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 shadow-sm overflow-hidden">
        <div className="p-8 border-b border-gray-100 dark:border-gray-800 text-center">
          <h2 className="text-2xl font-bold text-gray-900 dark:text-white mb-2">Setup New Match</h2>
          <p className="text-gray-500 dark:text-gray-400">Configure your match settings</p>
        </div>
        
        <form onSubmit={handleSubmit} className="p-8 space-y-8">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-8 relative">
            <div className="hidden md:flex absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-12 h-12 bg-gray-100 dark:bg-gray-800 rounded-full items-center justify-center border-2 border-gray-200 dark:border-gray-700 z-10 font-bold text-gray-500 dark:text-gray-400">VS</div>

            {/* Player 1 Config */}
            <div className="space-y-4">
              <label className="block text-sm font-medium text-red-500 dark:text-red-400 uppercase tracking-wider">Player 1 (Red)</label>
              <div className="flex gap-2 p-1 bg-gray-100 dark:bg-gray-800 rounded-lg">
                <button type="button" onClick={() => setP1Type('human')} className={`flex-1 flex items-center justify-center gap-2 py-2 rounded-md text-sm transition ${p1Type === 'human' ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200'}`}><User size={16} /> Human</button>
                <button type="button" onClick={() => setP1Type('ai')} className={`flex-1 flex items-center justify-center gap-2 py-2 rounded-md text-sm transition ${p1Type === 'ai' ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200'}`}><Bot size={16} /> AI</button>
              </div>
              {p1Type === 'ai' && <ModelSelect value={p1Model} onChange={setP1Model} />}
            </div>

            {/* Player 2 Config */}
            <div className="space-y-4">
              <label className="block text-sm font-medium text-yellow-500 dark:text-yellow-400 uppercase tracking-wider">Player 2 (Yellow)</label>
              <div className="flex gap-2 p-1 bg-gray-100 dark:bg-gray-800 rounded-lg">
                <button type="button" onClick={() => setP2Type('human')} className={`flex-1 flex items-center justify-center gap-2 py-2 rounded-md text-sm transition ${p2Type === 'human' ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200'}`}><User size={16} /> Human</button>
                <button type="button" onClick={() => setP2Type('ai')} className={`flex-1 flex items-center justify-center gap-2 py-2 rounded-md text-sm transition ${p2Type === 'ai' ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200'}`}><Bot size={16} /> AI</button>
              </div>
              {p2Type === 'ai' && <ModelSelect value={p2Model} onChange={setP2Model} />}
            </div>
          </div>

          {/* Randomize Button */}
          <button 
            type="button"
            onClick={handleRandomize}
            disabled={loading || loadingModels}
            className="w-full mb-4 bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-200 font-medium py-3 rounded-lg border border-gray-200 dark:border-gray-700 flex items-center justify-center gap-2 transition-colors"
          >
            <Shuffle size={20} />
            Randomize Matchup
          </button>

          <button type="submit" disabled={loading || loadingModels} className="w-full bg-brand-600 hover:bg-brand-700 disabled:bg-gray-400 text-white font-medium py-3 rounded-lg shadow-sm flex items-center justify-center gap-2 transition-colors">
            {loading ? <span className="animate-pulse">Starting Match...</span> : <><Sword size={20} /> Start Game</>}
          </button>
        </form>
      </div>
    </div>
  );
};

export default NewGame;
--- End of File: frontend/src/pages/NewGame.jsx ---

--- File: frontend/src/pages/Statistics.jsx ---
import React, { useEffect, useState } from 'react';
import { getLeaderboard, getMatrix, getHistory } from '../api/client';
import { 
  BarChart2, RefreshCw, Zap, Clock, Coins, Activity, 
  Maximize2, X, ChevronDown, ChevronUp, Table as TableIcon, Filter
} from 'lucide-react';
import {
  LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip as ReTooltip, Legend, ResponsiveContainer,
  ScatterChart, Scatter, ZAxis, LabelList, Brush, ReferenceLine
} from 'recharts';

// --- Utility: Deterministic Colors for Models ---
const COLORS = [
  '#2563eb', // blue-600
  '#dc2626', // red-600
  '#ca8a04', // yellow-600
  '#16a34a', // green-600
  '#9333ea', // purple-600
  '#db2777', // pink-600
  '#0891b2', // cyan-600
  '#ea580c', // orange-600
  '#4b5563', // gray-600 (human)
  '#0d9488', // teal-600
  '#be185d', // pink-700
  '#4338ca', // indigo-700
  '#15803d', // green-700
  '#b45309', // amber-700
];

const getModelColor = (modelName, index) => {
  if (modelName === 'human') return '#4b5563';
  let hash = 0;
  for (let i = 0; i < modelName.length; i++) {
    hash = modelName.charCodeAt(i) + ((hash << 5) - hash);
  }
  const positiveHash = Math.abs(hash);
  return COLORS[positiveHash % COLORS.length];
};

// --- Custom Tooltip for Scatter Plots ---
const ScatterTooltip = ({ active, payload }) => {
  if (active && payload && payload.length) {
    const data = payload[0].payload;
    return (
      <div className="bg-white dark:bg-gray-900 p-3 border border-gray-200 dark:border-gray-700 shadow-lg rounded-lg text-xs z-50">
        <p className="font-bold text-gray-900 dark:text-white mb-2 text-sm">{data.model_name}</p>
        <div className="space-y-1">
          <p className="text-gray-500">ELO: <span className="font-mono text-gray-900 dark:text-white">{Math.round(data.rating)}</span></p>
          {data.avg_cost_per_game !== undefined && (
            <p className="text-emerald-600">Cost: <span className="font-mono">${data.avg_cost_per_game}/game</span></p>
          )}
          {data.mean_time_per_move !== undefined && (
            <p className="text-blue-600">Time: <span className="font-mono">{data.mean_time_per_move}s/move</span></p>
          )}
          {data.mean_tokens_out_per_move !== undefined && (
            <p className="text-purple-600">Output: <span className="font-mono">{data.mean_tokens_out_per_move} toks/move</span></p>
          )}
        </div>
      </div>
    );
  }
  return null;
};

// --- Chart Sub-Components ---

const MatrixView = ({ matrix }) => {
  if (!matrix) return null;
  return (
    <div className="overflow-x-auto h-full">
       <table className="w-full text-xs border-collapse h-full">
          <thead>
            <tr>
              <th className="p-2 bg-gray-50 dark:bg-gray-800 text-left min-w-[100px] sticky top-0 z-10">Model</th>
              {matrix.models.map(m => (
                <th key={m} className="p-2 bg-gray-50 dark:bg-gray-800 font-mono rotate-0 whitespace-nowrap overflow-hidden text-ellipsis max-w-[80px] sticky top-0 z-10" title={m}>
                  {m}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {matrix.models.map(rowModel => (
              <tr key={rowModel}>
                <td className="p-2 font-medium bg-gray-50 dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 truncate max-w-[120px]" title={rowModel}>
                  {rowModel}
                </td>
                {matrix.models.map(colModel => {
                  const cell = matrix.grid[rowModel][colModel];
                  if (rowModel === colModel) return <td key={colModel} className="bg-gray-100 dark:bg-gray-800"></td>;
                  if (cell.total === 0) return <td key={colModel} className="text-center text-gray-300 dark:text-gray-700">-</td>;

                  let bgColor;
                  const rate = cell.win_rate;
                  if (rate > 55) bgColor = `rgba(34, 197, 94, ${(rate - 50) / 50 * 0.5 + 0.2})`; // Green
                  else if (rate < 45) bgColor = `rgba(239, 68, 68, ${(50 - rate) / 50 * 0.5 + 0.2})`; // Red
                  else bgColor = 'rgba(107, 114, 128, 0.1)'; // Neutral

                  return (
                    <td 
                      key={colModel} 
                      className="text-center p-2 border border-gray-100 dark:border-gray-800 cursor-help transition-opacity hover:opacity-80"
                      style={{ backgroundColor: bgColor }}
                      title={`${rowModel} vs ${colModel}\nWins: ${cell.wins}, Losses: ${cell.losses}, Draws: ${cell.draws}\nTotal: ${cell.total}`}
                    >
                       <span className="font-bold text-gray-800 dark:text-gray-200">{Math.round(rate)}%</span>
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
    </div>
  );
};

const ScatterPlotView = ({ data, xKey, yKey, name, unit, fill, xLabel }) => {
  return (
    <ResponsiveContainer width="100%" height="100%">
      <ScatterChart margin={{ top: 20, right: 30, bottom: 20, left: 0 }}>
        <CartesianGrid strokeDasharray="3 3" opacity={0.1} />
        <XAxis type="number" dataKey={xKey} name={name} unit={unit} label={{ value: xLabel, position: 'bottom', offset: 0 }} stroke="#9ca3af" />
        <YAxis type="number" dataKey={yKey} name="ELO" domain={['auto', 'auto']} stroke="#9ca3af" />
        <ReTooltip cursor={{ strokeDasharray: '3 3' }} content={<ScatterTooltip />} />
        <Scatter name="Models" data={data} fill={fill}>
           {data.map((entry, index) => (
             <cell key={`cell-${index}`} fill={getModelColor(entry.model_name, index)} />
           ))}
           <LabelList dataKey="model_name" position="top" style={{ fontSize: '10px', fill: '#6b7280' }} />
        </Scatter>
      </ScatterChart>
    </ResponsiveContainer>
  );
};

// --- UPDATED: Cleaner History Plot ---
const HistoryPlotView = ({ data, models, visibleModels, toggleModel }) => {
  return (
    <div className="flex flex-col h-full">
      {/* Legend / Filter Control */}
      <div className="flex flex-wrap gap-2 mb-4 px-2 max-h-20 overflow-y-auto">
        {models.map((modelName, index) => (
          <button
            key={modelName}
            onClick={() => toggleModel(modelName)}
            className={`px-2 py-1 rounded text-xs font-medium border transition-all flex items-center gap-1 ${
              visibleModels.includes(modelName)
                ? 'bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 shadow-sm opacity-100'
                : 'bg-transparent border-transparent opacity-40 hover:opacity-70'
            }`}
            style={{ color: getModelColor(modelName, index) }}
          >
            <div 
              className="w-2 h-2 rounded-full" 
              style={{ backgroundColor: visibleModels.includes(modelName) ? getModelColor(modelName, index) : 'gray' }} 
            />
            {modelName}
          </button>
        ))}
      </div>

      <div className="flex-1 min-h-0">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={data} margin={{ top: 5, right: 30, left: 0, bottom: 5 }}>
            <CartesianGrid strokeDasharray="3 3" opacity={0.1} vertical={false} />
            <XAxis 
              dataKey="index" 
              stroke="#9ca3af" 
              tick={{fontSize: 12}}
              label={{ value: 'Games Played (Chronological)', position: 'insideBottom', offset: -5, fill: '#6b7280', fontSize: 12 }} 
            />
            <YAxis 
              domain={['auto', 'auto']} 
              stroke="#9ca3af" 
              tick={{fontSize: 12}}
              width={40}
              allowDecimals={false} // Force integers on Axis
            />
            
            {/* Reference Line at Starting ELO */}
            <ReferenceLine y={1200} stroke="#9ca3af" strokeDasharray="3 3" label={{ value: 'Base 1200', position: 'right', fill: '#9ca3af', fontSize: 10 }} />

            <ReTooltip 
              contentStyle={{ backgroundColor: '#1f2937', border: '1px solid #374151', borderRadius: '8px', color: '#fff', fontSize: '12px' }}
              itemStyle={{ padding: 0 }}
              labelStyle={{ color: '#9ca3af', marginBottom: '0.5rem' }}
            />
            
            {models.map((modelName, index) => (
              visibleModels.includes(modelName) && (
                <Line 
                  key={modelName}
                  type="linear" // UPDATE: Straight lines (no smoothing)
                  dataKey={modelName} 
                  stroke={getModelColor(modelName, index)} 
                  strokeWidth={2}
                  dot={false} 
                  activeDot={{ r: 6, strokeWidth: 0 }} 
                  connectNulls={true} 
                  isAnimationActive={false} 
                />
              )
            ))}
            
            {/* Zoom Slider */}
            <Brush 
              dataKey="index" 
              height={30} 
              stroke="#4b5563" 
              fill="transparent" 
              tickFormatter={() => ''}
            />
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
};

const Statistics = () => {
  const [leaderboard, setLeaderboard] = useState([]);
  const [matrix, setMatrix] = useState(null);
  const [historyData, setHistoryData] = useState([]);
  const [loading, setLoading] = useState(true);
  
  // UI States
  const [showTable, setShowTable] = useState(false);
  const [expandedChart, setExpandedChart] = useState(null);
  
  // Filtering for History Chart
  const [allModels, setAllModels] = useState([]);
  const [visibleModels, setVisibleModels] = useState([]);

  const fetchData = async () => {
    setLoading(true);
    try {
      const [lbData, matrixData, histData] = await Promise.all([
        getLeaderboard(),
        getMatrix(),
        getHistory()
      ]);
      setLeaderboard(lbData);
      setMatrix(matrixData);
      
      const modelsList = lbData.map(m => m.model_name);
      setAllModels(modelsList);
      
      // --- LOGIC UPDATE HERE ---
      // Old Code: setVisibleModels(modelsList.slice(0, 5));
      // New Code: Set all models as visible by default
      if (visibleModels.length === 0) {
        setVisibleModels(modelsList); 
      }

      processHistoryData(histData);
    } catch (e) {
      console.error(e);
    } finally {
      setLoading(false);
    }
  };

  // 2. UPDATE: Data Processing Logic (Horizontal Extension)
  const processHistoryData = (rawHistory) => {
    const grouped = {};
    // Group history entries by model name
    rawHistory.forEach(entry => {
      if (!grouped[entry.model_name]) grouped[entry.model_name] = [];
      grouped[entry.model_name].push(entry);
    });

    // Find the maximum number of games played by ANY model
    let maxGames = 0;
    Object.values(grouped).forEach(arr => {
      if (arr.length > maxGames) maxGames = arr.length;
    });

    const plotData = [];
    const lastRatings = {}; // Cache to store the last known rating for each model

    // Iterate from 0 to maxGames to build the timeline
    for (let i = 0; i < maxGames; i++) {
      const point = { index: i + 1 };
      
      Object.keys(grouped).forEach(model => {
        // If this model has a game at this index (e.g., their 5th game)
        if (grouped[model][i]) {
          const val = Math.round(grouped[model][i].rating);
          point[model] = val;
          lastRatings[model] = val; // Update last known rating
        } 
        // If no game at this index, use the last known rating (Fill Forward)
        else if (lastRatings[model] !== undefined) {
          point[model] = lastRatings[model];
        }
        // If lastRatings is undefined, the model hasn't played its 1st game yet; leave undefined.
      });
      
      plotData.push(point);
    }
    setHistoryData(plotData);
  };

  useEffect(() => {
    fetchData();
  }, []);

  const toggleModelVisibility = (modelName) => {
    setVisibleModels(prev => 
      prev.includes(modelName) 
        ? prev.filter(m => m !== modelName)
        : [...prev, modelName]
    );
  };

  const aiOnlyLeaderboard = leaderboard.filter(m => m.model_name !== 'human');

  // --- Modal Renderer ---
  const renderExpandedContent = () => {
    switch (expandedChart) {
      case 'matrix': return <MatrixView matrix={matrix} />;
      case 'cost': return <ScatterPlotView data={aiOnlyLeaderboard} xKey="avg_cost_per_game" yKey="rating" name="Cost" unit="$" fill="#10b981" xLabel="$/Game" />;
      case 'time': return <ScatterPlotView data={aiOnlyLeaderboard} xKey="mean_time_per_move" yKey="rating" name="Time" unit="s" fill="#3b82f6" xLabel="Seconds/Move" />;
      case 'tokens': return <ScatterPlotView data={aiOnlyLeaderboard} xKey="mean_tokens_out_per_move" yKey="rating" name="Tokens" unit="T" fill="#8b5cf6" xLabel="Tokens/Move" />;
      case 'history': return <HistoryPlotView data={historyData} models={allModels} visibleModels={visibleModels} toggleModel={toggleModelVisibility} />;
      default: return null;
    }
  };

  // --- Helper to wrap charts in a card with expand button ---
  const ChartCard = ({ title, icon: Icon, color, id, children }) => (
    <div 
      className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 shadow-sm p-4 relative group flex flex-col h-[400px] transition-all hover:border-brand-300 dark:hover:border-brand-700"
      onClick={() => setExpandedChart(id)}
    >
      <div className={`flex items-center gap-2 mb-2 text-sm font-bold ${color} shrink-0`}>
        <Icon size={16} /> <span>{title}</span>
      </div>
      <div className="flex-1 min-h-0 cursor-pointer overflow-hidden">
        {children}
      </div>
      <div className="absolute top-3 right-3 opacity-0 group-hover:opacity-100 transition-opacity z-10">
        <button className="p-1.5 bg-gray-100 dark:bg-gray-800 rounded-lg text-gray-500 hover:text-brand-600 shadow-sm border border-gray-200 dark:border-gray-700">
           <Maximize2 size={16} />
        </button>
      </div>
    </div>
  );

  return (
    <div className="max-w-[1400px] mx-auto space-y-6 pb-12">
      
      {/* --- Header & Controls --- */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <BarChart2 className="text-brand-600 dark:text-brand-500" size={32} />
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Analytics Center</h1>
        </div>
        <button 
          onClick={fetchData} 
          className="p-2 bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-800 rounded-lg text-gray-500 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
        >
          <RefreshCw size={20} className={loading ? "animate-spin" : ""} />
        </button>
      </div>

      {/* --- Collapsible FULL Leaderboard Table --- */}
      <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 shadow-sm overflow-hidden">
        <button 
          onClick={() => setShowTable(!showTable)}
          className="w-full px-6 py-4 flex items-center justify-between bg-gray-50 dark:bg-gray-800/50 hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
        >
          <div className="flex items-center gap-2 text-gray-900 dark:text-white font-semibold">
            <TableIcon size={18} className="text-brand-600 dark:text-brand-400" />
            Full Model Leaderboard
          </div>
          {showTable ? <ChevronUp size={20} className="text-gray-500"/> : <ChevronDown size={20} className="text-gray-500"/>}
        </button>
        
        {showTable && (
          <div className="overflow-x-auto border-t border-gray-100 dark:border-gray-800">
            <table className="w-full text-xs text-left">
              <thead className="bg-gray-50 dark:bg-gray-800/50 text-gray-500 dark:text-gray-400 uppercase">
                <tr>
                  <th className="px-4 py-3 font-medium text-left">Model</th>
                  <th className="px-2 py-3 font-medium text-right">ELO</th>
                  <th className="px-2 py-3 font-medium text-right">Win%</th>
                  <th className="px-2 py-3 font-medium text-right">Games</th>
                  
                  {/* Stats */}
                  <th className="px-2 py-3 font-medium text-right text-gray-400">Time/Mv</th>
                  <th className="px-2 py-3 font-medium text-right text-gray-400">Moves/Game</th>
                  <th className="px-2 py-3 font-medium text-right text-gray-400">Tok/Mv</th>
                  <th className="px-2 py-3 font-medium text-right text-gray-400">Total Tok</th>
                  
                  {/* Economics */}
                  <th className="px-2 py-3 font-medium text-right text-emerald-600">$/Mv</th>
                  <th className="px-2 py-3 font-medium text-right text-emerald-600">$/Game</th>
                  <th className="px-2 py-3 font-medium text-right text-emerald-600">Total $</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-100 dark:divide-gray-800">
                {leaderboard.map((row) => {
                  const total = row.wins + row.losses + row.draws;
                  const wr = total > 0 ? ((row.wins / total) * 100).toFixed(1) : 0;
                  return (
                    <tr key={row.model_name} className="hover:bg-gray-50 dark:hover:bg-gray-800/50">
                      <td className="px-4 py-3 font-medium text-gray-900 dark:text-white truncate max-w-[150px]" title={row.model_name}>
                        {row.model_name}
                      </td>
                      <td className="px-2 py-3 text-right font-mono text-brand-600 dark:text-brand-400 font-bold">{Math.round(row.rating)}</td>
                      <td className="px-2 py-3 text-right">{wr}%</td>
                      <td className="px-2 py-3 text-right text-gray-500">{row.matches_played}</td>
                      
                      {/* Stats */}
                      <td className="px-2 py-3 text-right font-mono text-gray-600 dark:text-gray-400">{row.mean_time_per_move}s</td>
                      <td className="px-2 py-3 text-right font-mono text-gray-600 dark:text-gray-400">{row.avg_moves_per_game}</td>
                      <td className="px-2 py-3 text-right font-mono text-gray-600 dark:text-gray-400">{row.mean_tokens_out_per_move}</td>
                      <td className="px-2 py-3 text-right font-mono text-gray-600 dark:text-gray-400">{(row.total_tokens_out / 1000000).toFixed(2)}M</td>
                      
                      {/* Economics */}
                      <td className="px-2 py-3 text-right font-mono text-emerald-600 dark:text-emerald-500">${row.avg_cost_per_move}</td>
                      <td className="px-2 py-3 text-right font-mono text-emerald-600 dark:text-emerald-500">${row.avg_cost_per_game}</td>
                      <td className="px-2 py-3 text-right font-mono text-emerald-600 dark:text-emerald-500 font-bold">${row.total_cost}</td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        )}
      </div>

      {/* --- Matrix --- */}
      <ChartCard title="Win Rate Matrix" icon={Activity} color="text-brand-600" id="matrix">
        <MatrixView matrix={matrix} />
      </ChartCard>

      {/* --- Scatter Plots Row --- */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <ChartCard title="Price vs Performance" icon={Coins} color="text-emerald-600" id="cost">
          <ScatterPlotView data={aiOnlyLeaderboard} xKey="avg_cost_per_game" yKey="rating" name="Cost" unit="$" fill="#10b981" xLabel="$/Game" />
        </ChartCard>

        <ChartCard title="Speed vs Performance" icon={Clock} color="text-blue-600" id="time">
           <ScatterPlotView data={aiOnlyLeaderboard} xKey="mean_time_per_move" yKey="rating" name="Time" unit="s" fill="#3b82f6" xLabel="Seconds/Move" />
        </ChartCard>

        <ChartCard title="Verbosity vs Performance" icon={Zap} color="text-purple-600" id="tokens">
           <ScatterPlotView data={aiOnlyLeaderboard} xKey="mean_tokens_out_per_move" yKey="rating" name="Tokens" unit="T" fill="#8b5cf6" xLabel="Tokens/Move" />
        </ChartCard>
      </div>

      {/* --- History --- */}
      <div className="h-[500px] w-full">
        <ChartCard title="ELO Progression History" icon={Activity} color="text-gray-900 dark:text-white" id="history">
          <HistoryPlotView 
            data={historyData} 
            models={allModels} 
            visibleModels={visibleModels}
            toggleModel={toggleModelVisibility}
          />
        </ChartCard>
      </div>


      {/* --- EXPANDED MODAL --- */}
      {expandedChart && (
        <div className="fixed inset-0 z-[100] bg-white dark:bg-gray-950 p-6 flex flex-col">
          {/* Modal Header */}
          <div className="flex justify-between items-center mb-6 shrink-0">
             <div className="flex items-center gap-3">
               <div className="p-2 bg-gray-100 dark:bg-gray-800 rounded-lg">
                 <Maximize2 size={24} className="text-brand-600 dark:text-brand-400" />
               </div>
               <div>
                  <h2 className="text-2xl font-bold text-gray-900 dark:text-white capitalize">
                    {expandedChart === 'matrix' ? 'Win Rate Matrix' : expandedChart + ' Analysis'}
                  </h2>
                  <p className="text-gray-500">Detailed View</p>
               </div>
             </div>
             <button 
               onClick={() => setExpandedChart(null)}
               className="p-3 bg-gray-100 dark:bg-gray-800 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors"
             >
               <X size={24} className="text-gray-600 dark:text-gray-300" />
             </button>
          </div>

          {/* Modal Content */}
          <div className="flex-1 min-h-0 bg-gray-50 dark:bg-gray-900/50 rounded-2xl border border-gray-200 dark:border-gray-800 p-6 overflow-hidden">
             {renderExpandedContent()}
          </div>
        </div>
      )}

    </div>
  );
};

export default Statistics;
--- End of File: frontend/src/pages/Statistics.jsx ---

--- File: frontend/src/pages/Tournament.jsx ---
import React, { useState, useEffect, useRef } from 'react'; // <--- Added useRef
import { 
  Trophy, Play, Square, Settings, 
  Cpu, Activity, CheckCircle2, AlertCircle, RefreshCw, ArrowRight as ArrowIcon
} from 'lucide-react';
import { 
  getModels, createTournament, startTournament, 
  stopTournament, getCurrentTournament, getActiveGames,
  pauseTournament, resumeTournament, updateTournamentConfig 
} from '../api/client';
import { Link } from 'react-router-dom';
import MiniGameBoard from '../components/MiniGameBoard'; // Import new component

const Tournament = () => {
  // Config State
  const [availableModels, setAvailableModels] = useState([]);
  const [selectedModels, setSelectedModels] = useState([]);
  const [rounds, setRounds] = useState(1);
  const [concurrency, setConcurrency] = useState(2);
  
  // Live State
  const [activeTournament, setActiveTournament] = useState(null);
  const [activeGames, setActiveGames] = useState([]);
  const [loading, setLoading] = useState(true);
  
  // Pause/Resume State
  const [editingConcurrency, setEditingConcurrency] = useState(2);
  const [isUpdatingConfig, setIsUpdatingConfig] = useState(false);

  // 2. Add Ref
  // Stores the ID of a tournament the user has explicitly closed/reset
  const dismissedIdRef = useRef(null); 

  // --- Initialization & Polling ---
  useEffect(() => {
    fetchInitialData();
    const interval = setInterval(refreshStatus, 3000); // Poll every 3s
    return () => clearInterval(interval);
  }, []);

  const fetchInitialData = async () => {
    try {
      const [modelsData, tournamentData] = await Promise.all([
        getModels(),
        getCurrentTournament()
      ]);
      setAvailableModels(modelsData);

      // 3. Logic Update: Don't load if dismissed (edge case on re-mount)
      if (tournamentData && dismissedIdRef.current !== tournamentData.id) {
        setActiveTournament(tournamentData);
        // Initialize editing concurrency with current config value
        setEditingConcurrency(tournamentData.config?.concurrency || 2);
      }
      
      // Pre-select first 3 models if setup
      if (!tournamentData && modelsData.length >= 3) {
        setSelectedModels(modelsData.slice(0, 3).map(m => m.id));
      }
    } catch (e) {
      console.error(e);
    } finally {
      setLoading(false);
    }
  };

  const refreshStatus = async () => {
    try {
      const t = await getCurrentTournament();
      
      // 4. Logic Update: THE FIX
      // If the backend returns a tournament that matches our dismissed ID, ignore it.
      if (t && dismissedIdRef.current === t.id) {
        return; 
      }

      setActiveTournament(t);
      // Update editing concurrency with current config value
      if (t) {
        setEditingConcurrency(t.config?.concurrency || 2);
      }
      
      if (t && t.status === 'IN_PROGRESS') {
        const games = await getActiveGames();
        
        // --- NEW LOGIC: STABLE SORT ---
        // Sort games by ID so they don't change positions in the grid during updates
        games.sort((a, b) => a.id - b.id);
        
        setActiveGames(games);
      }
    } catch (e) {
      console.error("Polling error", e);
    }
  };

  // --- Handlers ---
  const toggleModel = (id) => {
    setSelectedModels(prev => 
      prev.includes(id) ? prev.filter(x => x !== id) : [...prev, id]
    );
  };

  const handleCreate = async () => {
    if (selectedModels.length < 2) return alert("Select at least 2 models");
    setLoading(true);
    try {
      // 5. Logic Update: Reset dismissal ref for the NEW tournament
      dismissedIdRef.current = null;
      
      const t = await createTournament(selectedModels, rounds, concurrency);
      setActiveTournament(t);
    } catch (e) {
      alert("Failed to create tournament");
    } finally {
      setLoading(false);
    }
  };

  const handleStart = async () => {
    if (!activeTournament) return;
    try {
      await startTournament(activeTournament.id);
      refreshStatus();
    } catch (e) {
      alert("Failed to start");
    }
  };

  const handleStop = async () => {
    if (!activeTournament) return;
    if (!confirm("Stop the tournament? Running games will finish, pending games will remain pending.")) return;
    try {
      await stopTournament(activeTournament.id);
      refreshStatus();
    } catch (e) {
      alert("Failed to stop");
    }
  };

  const handlePause = async () => {
    if (!activeTournament) return;
    try {
      await pauseTournament(activeTournament.id);
      // Optimistically update local state for instant feedback
      setActiveTournament(prev => ({...prev, status: 'PAUSED'}));
      refreshStatus();
    } catch (e) {
      alert("Failed to pause tournament");
    }
  };

  const handleResume = async () => {
    if (!activeTournament) return;
    try {
      await resumeTournament(activeTournament.id);
      // Optimistically update local state for instant feedback
      setActiveTournament(prev => ({...prev, status: 'IN_PROGRESS'}));
      refreshStatus();
    } catch (e) {
      alert("Failed to resume tournament");
    }
  };

  const handleUpdateConfig = async () => {
    if (!activeTournament) return;
    setIsUpdatingConfig(true);
    try {
      await updateTournamentConfig(activeTournament.id, editingConcurrency);
      // Update local tournament config
      setActiveTournament(prev => ({
        ...prev,
        config: {...prev.config, concurrency: editingConcurrency}
      }));
      alert("Configuration updated successfully");
    } catch (e) {
      alert("Failed to update configuration");
    } finally {
      setIsUpdatingConfig(false);
    }
  };

  const handleReset = () => {
    // 6. Logic Update: Mark current ID as dismissed
    if (activeTournament) {
      dismissedIdRef.current = activeTournament.id;
    }
    setActiveTournament(null); 
  };

  // --- Calculations ---
  const n = selectedModels.length;
  const matchesPerRound = n * (n - 1);
  const totalCalculated = matchesPerRound * rounds;

  if (loading && !activeTournament) return <div className="p-10 text-center">Loading...</div>;

  // --- VIEW: ACTIVE TOURNAMENT ---
  if (activeTournament && activeTournament.status !== 'COMPLETED' && activeTournament.status !== 'STOPPED') {
    const pct = Math.round((activeTournament.completed / activeTournament.total) * 100) || 0;
    
    // SAFE ACCESS: Use ?.config?. to prevent crashes if config isn't loaded yet
    const config = activeTournament.config || {}; 

    return (
      <div className="max-w-6xl mx-auto space-y-6">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-bold flex items-center gap-2 dark:text-white">
            <Trophy className="text-yellow-500" /> Tournament #{activeTournament.id}
          </h1>
          <div className="flex gap-2">
            {activeTournament.status === 'SETUP' && (
              <button onClick={handleStart} className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg flex items-center gap-2">
                <Play size={18} /> Start Now
              </button>
            )}
            {activeTournament.status === 'IN_PROGRESS' && (
              <>
                <button onClick={handlePause} className="bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded-lg flex items-center gap-2">
                  <Square size={18} /> Pause
                </button>
                <button onClick={handleStop} className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg flex items-center gap-2">
                  <Square size={18} /> Stop
                </button>
              </>
            )}
            {activeTournament.status === 'PAUSED' && (
              <button onClick={handleResume} className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg flex items-center gap-2">
                <Play size={18} /> Resume
              </button>
            )}
          </div>
        </div>

        {/* Status Card */}
        <div className="bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 p-6 shadow-sm">
           <div className="flex justify-between text-sm mb-2 text-gray-500">
             <span>Progress</span>
             <span>{activeTournament.completed} / {activeTournament.total} Games</span>
           </div>
           <div className="w-full bg-gray-200 dark:bg-gray-800 rounded-full h-4 mb-6 overflow-hidden">
             <div 
               className="bg-brand-600 h-4 rounded-full transition-all duration-500 relative" 
               style={{ width: `${pct}%` }}
             >
                <div className="absolute inset-0 bg-white/20 animate-[shimmer_2s_infinite]"></div>
             </div>
           </div>
           
           <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
             <div className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
                <div className="text-gray-500">Status</div>
                <div className="font-bold dark:text-white">{activeTournament.status}</div>
             </div>
             <div className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
                <div className="text-gray-500">Concurrency</div>
                {activeTournament.status === 'PAUSED' ? (
                  <div className="space-y-2">
                    <div className="flex justify-between items-center">
                      <span className="font-bold dark:text-white">{editingConcurrency} Workers</span>
                      <button 
                        onClick={handleUpdateConfig}
                        disabled={isUpdatingConfig}
                        className="px-2 py-1 bg-brand-600 text-white text-xs rounded hover:bg-brand-700 disabled:opacity-50"
                      >
                        {isUpdatingConfig ? 'Saving...' : 'Save'}
                      </button>
                    </div>
                    <input 
                      type="range" 
                      min="1" 
                      max="100" 
                      step="1"
                      value={editingConcurrency} 
                      onChange={(e) => setEditingConcurrency(parseInt(e.target.value))}
                      className="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-brand-600"
                    />
                    <p className="text-xs text-gray-500">Adjust while paused</p>
                  </div>
                ) : (
                  <div className="font-bold dark:text-white">{config.concurrency || 2} Workers</div>
                )}
             </div>
             <div className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
                <div className="text-gray-500">Rounds</div>
                {/* FIXED: Added Optional Chaining here */}
                <div className="font-bold dark:text-white">{config.rounds || 1}</div>
             </div>
             <div className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
                <div className="text-gray-500">Models</div>
                {/* FIXED: Added Optional Chaining here */}
                <div className="font-bold dark:text-white">{config.model_ids?.length || 0}</div>
             </div>
           </div>
        </div>

        {/* Active Games Grid */}
        <div className="space-y-4">
           <h2 className="text-lg font-semibold flex items-center gap-2 dark:text-white">
             <Activity size={20} className="text-brand-500" /> Live Matches
           </h2>
           
           {activeGames.length === 0 ? (
             <div className="p-8 text-center text-gray-500 bg-white dark:bg-gray-900 rounded-xl border border-dashed border-gray-300 dark:border-gray-700">
                {activeTournament.status === 'SETUP' ? "Waiting to start..." : "Spinning up workers..."}
             </div>
           ) : (
             <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
               {activeGames.map(game => (
                 <Link 
                   key={game.id} 
                   to={`/game/${game.id}`} 
                   className="block bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 p-4 hover:border-brand-500 dark:hover:border-brand-500 hover:shadow-md transition-all group"
                 >
                    {/* Header: ID + Move Count */}
                    <div className="flex justify-between items-center mb-3">
                       <span className="text-xs font-mono text-gray-400">#{game.id}</span>
                       <div className="flex gap-2">
                         <span className="flex items-center gap-1 text-[10px] font-bold text-gray-500 dark:text-gray-400 bg-gray-100 dark:bg-gray-800 px-2 py-0.5 rounded-full">
                           <RefreshCw size={10} className={activeTournament.status === 'IN_PROGRESS' ? 'animate-spin' : ''}/>
                           {game.move_count || 0}
                         </span>
                       </div>
                    </div>

                    {/* Body: Board + Players */}
                    <div className="flex gap-4">
                      {/* Mini Board */}
                      <div className="shrink-0">
                         <MiniGameBoard board={game.board} />
                      </div>

                      {/* Players */}
                      <div className="flex-1 flex flex-col justify-center gap-2 overflow-hidden">
                        <div className="flex items-center gap-2 min-w-0">
                          <div className="w-2 h-2 rounded-full bg-red-500 shrink-0 shadow-sm" />
                          <span className="text-xs font-medium text-gray-700 dark:text-gray-300 truncate" title={game.player_1}>
                            {game.player_1}
                          </span>
                        </div>
                        <div className="flex items-center gap-2 min-w-0">
                          <div className="w-2 h-2 rounded-full bg-yellow-400 shrink-0 shadow-sm" />
                          <span className="text-xs font-medium text-gray-700 dark:text-gray-300 truncate" title={game.player_2}>
                            {game.player_2}
                          </span>
                        </div>
                      </div>
                    </div>

                    {/* Footer: Live Indicator */}
                    <div className="mt-3 flex items-center justify-between border-t border-gray-50 dark:border-gray-800 pt-2">
                        <span className="flex items-center gap-1.5 text-[10px] font-bold tracking-wider text-green-600 dark:text-green-400 uppercase">
                          <span className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse" />
                          Live
                        </span>
                        <div className="text-gray-400 group-hover:text-brand-600 dark:group-hover:text-brand-400 transition-colors">
                           <ArrowIcon size={14} />
                        </div>
                    </div>
                 </Link>
               ))}
             </div>
           )}
        </div>
      </div>
    );
  }

  // --- VIEW: COMPLETED / STOPPED ---
  if (activeTournament) {
    return (
      <div className="max-w-2xl mx-auto text-center space-y-6 pt-10">
        <div className="bg-white dark:bg-gray-900 p-8 rounded-2xl border border-gray-200 dark:border-gray-800 shadow-sm">
           <CheckCircle2 size={64} className="mx-auto text-green-500 mb-4" />
           <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-2">Tournament Finished</h1>
           <p className="text-gray-500 mb-6">All {activeTournament.total} scheduled matches have been processed.</p>
           
           <div className="flex justify-center gap-4">
             <button onClick={handleReset} className="px-6 py-2 bg-brand-600 text-white rounded-lg hover:bg-brand-700">
               Start New Tournament
             </button>
             <Link to="/statistics" className="px-6 py-2 bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white rounded-lg hover:bg-gray-200">
               View Leaderboard
             </Link>
           </div>
        </div>
      </div>
    );
  }

  // --- VIEW: SETUP FORM ---
  return (
    <div className="max-w-4xl mx-auto">
      <div className="mb-6">
        <h1 className="text-2xl font-bold dark:text-white flex items-center gap-2">
           <Settings className="text-brand-600" /> Tournament Setup
        </h1>
        <p className="text-gray-500 dark:text-gray-400">Configure an automated Round Robin tournament.</p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
         {/* Left: Configuration */}
         <div className="lg:col-span-2 space-y-6">
            
            {/* Model Selection */}
            <div className="bg-white dark:bg-gray-900 p-6 rounded-xl border border-gray-200 dark:border-gray-800 shadow-sm">
               <h3 className="font-semibold mb-4 flex items-center gap-2 dark:text-white">
                 <Cpu size={18} /> Select Models ({selectedModels.length})
               </h3>
               <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 max-h-60 overflow-y-auto pr-2">
                 {availableModels.map(m => (
                   <div 
                     key={m.id}
                     onClick={() => toggleModel(m.id)}
                     className={`p-3 rounded-lg border cursor-pointer transition-all flex items-center justify-between ${
                       selectedModels.includes(m.id)
                         ? 'bg-brand-50 border-brand-500 dark:bg-brand-900/20'
                         : 'bg-gray-50 border-gray-200 dark:bg-gray-800 dark:border-gray-700 hover:border-gray-300'
                     }`}
                   >
                     <div className="text-sm font-medium dark:text-gray-200">{m.label}</div>
                     {selectedModels.includes(m.id) && <CheckCircle2 size={16} className="text-brand-600" />}
                   </div>
                 ))}
               </div>
            </div>

            {/* Sliders */}
            <div className="bg-white dark:bg-gray-900 p-6 rounded-xl border border-gray-200 dark:border-gray-800 shadow-sm space-y-6">
               <div>
                  <div className="flex justify-between mb-2">
                    <label className="font-semibold dark:text-white flex items-center gap-2"><RefreshCw size={18}/> Rounds (Cycles)</label>
                    <span className="text-brand-600 font-mono font-bold">{rounds}</span>
                  </div>
                  <input 
                    type="range" min="1" max="10" step="1"
                    value={rounds} onChange={(e) => setRounds(parseInt(e.target.value))}
                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-brand-600"
                  />
                  <p className="text-xs text-gray-500 mt-1">Number of times every pair plays each other (swapping sides).</p>
               </div>

               <div>
                  <div className="flex justify-between mb-2">
                    <label className="font-semibold dark:text-white flex items-center gap-2"><Activity size={18}/> Concurrency</label>
                    <span className="text-brand-600 font-mono font-bold">{concurrency}</span>
                  </div>
                  <input 
                    type="range" min="1" max="100" step="1"
                    value={concurrency} onChange={(e) => setConcurrency(parseInt(e.target.value))}
                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-brand-600"
                  />
                  <p className="text-xs text-gray-500 mt-1">Max simultaneous games. Higher = Faster but heavier on API/DB.</p>
               </div>
            </div>
         </div>

         {/* Right: Summary */}
         <div className="lg:col-span-1">
            <div className="bg-white dark:bg-gray-900 p-6 rounded-xl border border-gray-200 dark:border-gray-800 shadow-sm sticky top-24">
               <h3 className="font-bold text-lg mb-4 dark:text-white">Summary</h3>
               
               <div className="space-y-3 text-sm border-b border-gray-100 dark:border-gray-800 pb-4 mb-4">
                 <div className="flex justify-between">
                   <span className="text-gray-500">Models</span>
                   <span className="font-mono dark:text-gray-200">{n}</span>
                 </div>
                 <div className="flex justify-between">
                   <span className="text-gray-500">Matchups (Round Robin)</span>
                   <span className="font-mono dark:text-gray-200">{matchesPerRound}</span>
                 </div>
                 <div className="flex justify-between">
                   <span className="text-gray-500">Total Rounds</span>
                   <span className="font-mono dark:text-gray-200">x {rounds}</span>
                 </div>
               </div>

               <div className="flex justify-between items-center mb-6">
                 <span className="font-bold text-gray-900 dark:text-white">Total Games</span>
                 <span className="text-xl font-bold text-brand-600">{totalCalculated}</span>
               </div>

               {n < 2 ? (
                 <div className="text-sm text-red-500 flex items-center gap-2 bg-red-50 p-3 rounded-lg">
                   <AlertCircle size={16} /> Select at least 2 models
                 </div>
               ) : (
                 <button 
                   onClick={handleCreate}
                   className="w-full py-3 bg-brand-600 hover:bg-brand-700 text-white font-bold rounded-xl shadow-lg hover:shadow-xl transition-all flex items-center justify-center gap-2"
                 >
                   {loading ? "Creating..." : <>Create & Queue <ArrowIcon size={18}/></>}
                 </button>
               )}
            </div>
         </div>
      </div>
    </div>
  );
};

export default Tournament;
--- End of File: frontend/src/pages/Tournament.jsx ---

--- File: frontend/src/App.css ---
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

--- End of File: frontend/src/App.css ---

--- File: frontend/src/App.jsx ---
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { ThemeProvider } from './context/ThemeContext';
import Layout from './components/Layout';
import Dashboard from './pages/Dashboard';
import Statistics from './pages/Statistics';
import Tournament from './pages/Tournament';
import NewGame from './pages/NewGame';
import Arena from './pages/Arena';
import Admin from './pages/Admin';
import History from './pages/History';

function App() {
  return (
    <ThemeProvider>
      <BrowserRouter>
        <Layout>
          <Routes>
            <Route path="/" element={<Dashboard />} />
            <Route path="/tournament" element={<Tournament />} />
            <Route path="/statistics" element={<Statistics />} />
            <Route path="/new" element={<NewGame />} />
            <Route path="/game/:id" element={<Arena />} />
            <Route path="/history" element={<History />} />
            <Route path="/admin" element={<Admin />} />
          </Routes>
        </Layout>
      </BrowserRouter>
    </ThemeProvider>
  );
}

export default App;
--- End of File: frontend/src/App.jsx ---

--- File: frontend/src/index.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 
   REMOVE the hardcoded bg-slate-900 and text-white.
   The Layout.jsx component now handles the theme background.
*/
body {
  @apply antialiased min-h-screen;
}

/* Optional: Add a clean scrollbar for the new professional look */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  @apply bg-transparent;
}
::-webkit-scrollbar-thumb {
  @apply bg-gray-300 dark:bg-gray-700 rounded-full;
}

--- End of File: frontend/src/index.css ---

--- File: frontend/src/main.jsx ---
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

--- End of File: frontend/src/main.jsx ---

--- File: frontend/.gitignore ---
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

--- End of File: frontend/.gitignore ---

--- File: frontend/Dockerfile ---
# frontend/Dockerfile
FROM node:20-alpine

WORKDIR /app

# Install dependencies first (Caching layer)
# Change: Use package*.json to match package.json OR package-lock.json
COPY package*.json ./
RUN npm install

# Copy source code
COPY . .

# Expose Vite Port
EXPOSE 5173

# Start Vite with --host to expose it to the Docker network
CMD ["npm", "run", "dev", "--", "--host"]
--- End of File: frontend/Dockerfile ---

--- File: frontend/README.md ---
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

--- End of File: frontend/README.md ---

--- File: frontend/eslint.config.js ---
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

--- End of File: frontend/eslint.config.js ---

--- File: frontend/index.html ---
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>temp-frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

--- End of File: frontend/index.html ---

--- File: frontend/package.json ---
{
  "name": "connect4-frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vitejs/plugin-react": "^4.2.1",
    "axios": "^1.6.7",
    "clsx": "^2.1.0",
    "framer-motion": "^11.0.3",
    "lucide-react": "^0.330.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.22.0",
    "recharts": "^2.12.0",
    "tailwind-merge": "^2.2.1"
  },
  "devDependencies": {
    "@types/react": "^18.2.55",
    "@types/react-dom": "^18.2.19",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.17",
    "eslint": "^8.56.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "vite": "^5.1.0"
  }
}

--- End of File: frontend/package.json ---

--- File: frontend/postcss.config.js ---
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
--- End of File: frontend/postcss.config.js ---

--- File: frontend/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class', // <--- CRITICAL FOR LIGHT/DARK MODE
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'], // Cleaner font stack
      },
      colors: {
        // Professional Brand Color (Indigo/Slate mix)
        brand: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          500: '#0ea5e9', // Primary Action
          600: '#0284c7',
          700: '#0369a1',
          900: '#0c4a6e',
        },
        // Keep board colors for game component
        board: "#1e40af",
        slot: "#ffffff",
      }
    },
  },
  plugins: [],
}
--- End of File: frontend/tailwind.config.js ---

--- File: frontend/vite.config.js ---
// frontend/vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    host: true, // Needed for Docker port mapping
    port: 5173,
    watch: {
      usePolling: true, // <--- CRITICAL: Enables Hot Reload in Docker/WSL
    },
  },
})

--- End of File: frontend/vite.config.js ---

--- File: .gitignore ---
.venv
backend/.env
__pycache__/
*.pyc
**/*.pyc
*.pyo
*.pyd
.Python
*.so
*.egg
*.egg-info/
dist/
build/
*.sqlite3
.DS_Store
*.log
.env.local
.env.development.local
.env.test.local
.env.production.local
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env

--- End of File: .gitignore ---

--- File: MODELS.md ---
# 🧠 AI Model Registry & Configuration

This document outlines the Large Language Models (LLMs) supported by the Connect Four Arena, how they are configured, and how to extend the list.

## 🏗 Architecture: Single Source of Truth

We use a **Backend-Driven Architecture** for model management. 

1.  **Master Config**: All models are defined in `backend/app/engine/ai.py`.
2.  **API Exposure**: The backend exposes `GET /models`.
3.  **Dynamic UI**: The Frontend (`NewGame.jsx`) fetches this list on load to populate the dropdowns. 

**🚫 Do not hardcode models in the Frontend.**

---

## 📋 Supported Models

As of the latest configuration, the following models are registered in the backend.

### 🟢 OpenAI (Frontier)
| Model ID | Label | Context Window | Notes |
| :--- | :--- | :--- | :--- |
| `gpt-5.1` | GPT-5.1 | 128k | Best for coding/agentic tasks |
| `gpt-5-pro` | GPT-5 Pro | 128k | High-precision reasoning |
| `gpt-5` | GPT-5 | 128k | Base frontier model |
| `gpt-5-mini` | GPT-5 Mini | 128k | Cost-efficient reasoning |
| `gpt-5-nano` | GPT-5 Nano | 128k | Fastest reasoning model |
| `gpt-4.1` | GPT-4.1 | 128k | Smartest non-reasoning model |
| `gpt-4o` | GPT-4o | 128k | Fallback / Standard |

### 🔵 Google (Gemini)
| Model ID | Label | Context Window | Notes |
| :--- | :--- | :--- | :--- |
| `gemini-3-pro-preview` | Gemini 3 Pro | 1M | Multimodal agentic power |
| `gemini-2.5-pro` | Gemini 2.5 Pro | 1M | Advanced thinking model |
| `gemini-2.5-flash` | Gemini 2.5 Flash | 1M | Low latency, high volume |
| `gemini-2.5-flash-lite`| Gemini 2.5 Flash-Lite | 1M | Ultra-fast cost optimized |

### 🟠 Anthropic (Claude)
| Model ID | Label | Context Window | Notes |
| :--- | :--- | :--- | :--- |
| `claude-sonnet-4.5` | Claude 4.5 Sonnet | 200k | Balanced intelligence |
| `claude-opus-4.5` | Claude 4.5 Opus | 200k | Maximum capability |
| `claude-haiku-4.5` | Claude 4.5 Haiku | 200k | Speed & efficiency |
| `claude-3-5-sonnet-20240620` | Claude 3.5 Sonnet | 200k | Legacy stable |

---

## ⚙️ How to Add a New Model

To add a new model (e.g., `gpt-6` or `gemini-4`), you **only** need to touch the backend.

1.  Open **`backend/app/engine/ai.py`**.
2.  Locate the `MODEL_PROVIDERS` dictionary.
3.  Add a new entry following this format:

```python
"new-model-id": {
    "provider": "openai",  # or "anthropic" or "google"
    "label": "New Model Name",
    "context": 128000
},
```

4.  Restart the Backend container to apply changes:

```bash
docker compose restart backend
```

The Frontend will automatically display the new model in the dropdown.

## 🧪 Verification

We have a script to verify that the Backend can successfully initialize these models and that your API keys are valid.

Run this command from the project root:

```bash
docker compose exec backend python backend/scripts/test_models.py
```

- ✅ **OK**: Model is reachable.
- ❌ **FAILED**: Check your .env API keys or the model ID.

## 🔑 Environment Variables

Ensure your .env file contains keys for all providers you intend to use:

```ini
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
GOOGLE_API_KEY=AIza...
```
--- End of File: MODELS.md ---

--- File: README.md ---
# Connect Four LLM Arena 🎯

A full-stack web platform to benchmark Large Language Models (LLMs) on the game of Connect Four.

## Features

- **Live Arena**: Human vs AI real-time gameplay
- **Replay System**: "Time-travel" through past games with LLM reasoning
- **Automated Tournament**: Background AI vs AI matches for ELO ratings

## Tech Stack

- **Backend**: Python 3.11+ (FastAPI)
- **Real-Time**: WebSockets (Native FastAPI)
- **Database**: PostgreSQL (SQLAlchemy + Alembic)
- **AI Orchestration**: LangChain with Pydantic JSON outputs
- **Frontend**: React (Vite) + Tailwind CSS
- **Containerization**: Docker & Docker Compose

## Project Structure

```
connect4-llm-arena/
├── backend/                    # Python / FastAPI
│   ├── app/
│   │   ├── api/               # Route Handlers
│   │   │   └── websocket_manager.py
│   │   ├── core/              # Config
│   │   │   ├── config.py
│   │   │   └── database.py
│   │   ├── engine/            # Pure Game Logic
│   │   │   ├── game.py        # ConnectFour rules
│   │   │   └── ai.py          # LangChain Agent
│   │   ├── models/            # Database Models
│   │   │   └── game_model.py
│   │   ├── schemas/           # Pydantic Schemas
│   │   │   └── game_schema.py
│   │   └── main.py            # FastAPI app
│   ├── migrations/            # Alembic (DB Migrations)
│   ├── requirements.txt
│   └── scripts/
│       └── init_db.py         # Database initialization
├── frontend/                  # React (Vite)
│   └── src/
│       ├── api/              # Axios wrappers
│       ├── components/       # Reusable UI
│       ├── hooks/           # useGameSocket.js
│       └── pages/           # Arena, Gallery, Replay
├── docker-compose.yml        # Postgres orchestration
└── README.md
```

## Getting Started

### Prerequisites

- Python 3.11+
- PostgreSQL
- OpenAI API key

### Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd Connect4
   ```

2. **Set up Python environment**
   ```bash
   python -m venv .venv
   source .venv/bin/activate  # On Windows: .venv\Scripts\activate
   pip install -r backend/requirements.txt
   ```

3. **Set up PostgreSQL**
   ```bash
   # Install PostgreSQL (Ubuntu/Debian)
   sudo apt-get update
   sudo apt-get install -y postgresql postgresql-contrib
   
   # Start PostgreSQL service
   sudo service postgresql start
   
   # Create database and user
   sudo -u postgres psql -c "CREATE DATABASE connect4_arena;"
   sudo -u postgres psql -c "CREATE USER connect4_user WITH PASSWORD 'connect4';"
   sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE connect4_arena TO connect4_user;"
   sudo -u postgres psql -c "ALTER USER connect4_user WITH SUPERUSER;"
   ```

4. **Configure environment variables**
   ```bash
   # Copy .env.example to .env and update values
   cp backend/.env.example backend/.env
   # Edit backend/.env with your OpenAI API key
   ```

5. **Initialize database**
   ```bash
   python -m backend.scripts.init_db
   ```

### Running the Application

1. **Start the backend server**
   ```bash
   uvicorn backend.app.main:app --reload --host 0.0.0.0 --port 8000
   ```

2. **API will be available at**: http://localhost:8000
   - API documentation: http://localhost:8000/docs
   - WebSocket endpoint: ws://localhost:8000/games/{id}/ws

### API Endpoints

- `POST /games` - Create a new game
- `GET /games/{id}` - Get game details and history
- `GET /games` - List completed games (for leaderboard)
- `WebSocket /games/{id}/ws` - Real-time gameplay

### WebSocket Protocol

**Connection**: `ws://localhost:8000/games/{game_id}/ws`

**Client → Server** (Human move):
```json
{ "action": "MOVE", "column": 3 }
```

**Server → Client** messages:
- `{"type": "UPDATE", "board_visual": "...", "current_turn": 1, ...}` - Game state update
- `{"type": "THINKING_START"}` - AI is thinking
- `{"type": "THINKING_END"}` - AI finished thinking

## Development Status

### ✅ Phase 1: Core Engine (Completed)
- ConnectFour game logic
- LangChain AI agent with structured outputs
- CLI testing script (`console_test.py`)

### ✅ Phase 2: Backend & Database (Completed)
- PostgreSQL database setup
- FastAPI REST endpoints
- WebSocket real-time game loop
- Game state persistence

### 🔄 Phase 3: Frontend (Next)
- React board component
- WebSocket hook integration
- Replay view with slider
- AI reasoning display

### 📋 Phase 4: Tournament System
- Automated AI vs AI matches
- ELO rating calculation
- Background tournament runner

## Testing

Run the console test:
```bash
python console_test.py
```

Test the API:
```bash
# Create a game
curl -X POST "http://localhost:8000/games" \
  -H "Content-Type: application/json" \
  -d '{"player_1": "human", "player_2": "ai"}'

# Get game details
curl "http://localhost:8000/games/1"
```

## License

MIT

## Acknowledgments

- Built with FastAPI, React, and LangChain
- Inspired by AI benchmarking challenges
- Connect Four game logic implementation
--- End of File: README.md ---

--- File: TECHNICAL_SPEC.md ---
# 🎯 Technical Specification: Connect Four LLM Arena (v2.1)

## 1. Project Overview
**Goal:** Build a full-stack competitive platform to benchmark Large Language Models (LLMs) on the game of Connect Four.
**Key Features:**
- **Live Arena:** Human vs. AI (Real-time) or Spectate AI vs. AI.
- **Unified Replay System:** Watch past games with a timeline slider and view LLM Reasoning for every move.
- **Automated Tournament:** A background system runs continuous matches between different models to calculate rankings.
- **Analytics Dashboard:** Live Leaderboards including ELO scores, Win Rates, and Token Usage/Cost tracking, plus ELO history graphs.

---

## 2. Technology Stack
- **Backend:** Python 3.11+ (FastAPI).
- **Real-Time:** WebSockets (Native FastAPI).
- **Database:** PostgreSQL (using SQLAlchemy + Alembic).
- **AI Orchestration:** LangChain (using with_structured_output for JSON).
- **Frontend:** React (Vite) + Tailwind CSS + Recharts (for analytics).
- **Infrastructure:** Docker & Docker Compose.

---

## 3. Project Structure
Monorepo Approach:

```text
connect4-llm-arena/
├── docker-compose.yml           # Database & App orchestration
├── .env                         # API Keys (OpenAI/Anthropic/Google) & DB URL
├── README.md
│
├── backend/                     # Python / FastAPI
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py              # App Entry Point
│   │   │
│   │   ├── api/                 # Route Handlers
│   │   │   ├── routes.py        # Game Management (CRUD)
│   │   │   ├── stats.py         # Leaderboard & Analytics Endpoints
│   │   │   └── websocket_manager.py # WebSocket Logic (Singleton)
│   │   │
│   │   ├── core/                # Configuration
│   │   │   └── database.py      # Async DB Session
│   │   │
│   │   ├── engine/              # Core Logic
│   │   │   ├── game.py          # Connect Four Rules Engine
│   │   │   ├── ai.py            # LangChain Agent Factory & Prompts
│   │   │   └── elo.py           # Ranking Math & Updates
│   │   │
│   │   ├── models/              # SQLAlchemy Models
│   │   │   ├── game_model.py    # Game Tables
│   │   │   └── elo_model.py     # Ranking Tables
│   │   │
│   │   └── schemas/             # Pydantic Schemas
│   │       └── game_schema.py   # API Types
│   │
│   ├── scripts/
│   │   ├── init_db.py           # DB Initialization Script
│   │   └── tournament.py        # Background Worker (AI vs AI)
│   └── requirements.txt
│
└── frontend/                    # React (Vite)
    ├── src/
        ├── components/          # Reusable UI (Board, Chat, Graph)
        ├── hooks/               # useGameSocket.js
        └── pages/               # Arena, Tournament, Leaderboard
```

---

## 4. Database Schema

### 4.1 Table: `games`
Stores match metadata and the full move log.

| Column | Type | Notes |
| :--- | :--- | :--- |
| `id` | Integer (PK) | Unique ID. |
| `created_at` | DateTime | |
| `player_1_type` | String | "human" or model name (e.g., "gpt-4o"). |
| `player_2_type` | String | "human" or model name. |
| `winner` | Integer | 1, 2, or NULL. |
| `status` | String | IN_PROGRESS, COMPLETED, DRAW. |
| `history` | JSONB | Critical: Stores the full game log. |

**Structure of history JSONB array:**
```json
[
  {
    "move_num": 1,
    "player": 1,
    "column": 3,
    "reasoning": "Starting center...",
    "input_tokens": 450,
    "output_tokens": 40
  }
]
```

### 4.2 Table: `elo_ratings`
Stores current standings.

| Column | Type | Notes |
| :--- | :--- | :--- |
| `model_name` | String (PK) | e.g., "claude-3-opus". |
| `rating` | Float | Standard ELO (starts at 1200.0). |
| `matches_played` | Integer | |
| `wins`/`losses`/`draws` | Integer | |
| `total_input_tokens` | BigInteger | Lifetime input token count. |
| `total_output_tokens` | BigInteger | Lifetime output token count. |

### 4.3 Table: `elo_history`
Stores time-series data for graphing.

| Column | Type | Notes |
| :--- | :--- | :--- |
| `id` | Integer (PK) | |
| `model_name` | String | |
| `rating` | Float | Rating snapshot after a match. |
| `timestamp` | DateTime | |
| `match_id` | Integer | Link to the game that caused the update. |

---

## 5. API & Communication Protocols

### 5.1 REST Endpoints
- `POST /games`: Start a new game.
- `GET /games/{id}`: Fetch game state and full history.
- `GET /stats/leaderboard`: Returns models sorted by Rank (including Token Usage columns).
- `GET /stats/history`: Returns historical ELO data points for graphing.
- `GET /stats/active-games`: Returns list of currently running AI vs AI games.

### 5.2 WebSocket Protocol (Live Play)
**URL:** `ws://api_host/games/{id}/ws`

**Architecture:** Singleton Connection Manager.
- The Backend maintains one Game Engine instance per Game ID in memory.
- Multiple clients (players + spectators) connecting to the same ID share this state.

**Events:**
- **Client -> Server:** `{ "action": "MOVE", "column": 3 }`
- **Server -> Client:**
  - `UPDATE`: Contains Board (ASCII), Turn, Status, and Last Move (w/ Reasoning).
  - `THINKING_START`: Signal to show spinner/loading state.
  - `THINKING_END`: Signal to unlock UI.

---

## 6. Implementation Logic

### 6.1 AI Agent Logic
- **Prompting:** The AI receives the current board state only (Visual Grid + Text Description) to save context window.
- **Output:** Strict JSON via Pydantic (reasoning, column).
- **Token Tracking:** We must use `include_raw=True` in LangChain to capture `usage_metadata` (Input/Output tokens) and save this to the DB history.

### 6.2 ELO Calculation
- **Trigger:** Runs only when a game finishes AND both players are AI models.
- **Algorithm:** Standard ELO (K=32).
- **Updates:**
  - Update `elo_ratings` (Score + Win/Loss counters + Token Sums).
  - Insert row into `elo_history`.

### 6.3 Tournament Worker (`scripts/tournament.py`)
- **Type:** Background Python Process (AsyncIO).
- **Loop:**
  1. Select 2 random models from config.
  2. Play Game (Headless - no WebSockets, direct DB calls).
  3. Save result.
  4. Update ELO.
  5. Repeat.

---

## 7. Frontend Views (React)

**Arena (Unified View):**
- **Board:** Interactive 7x6 Grid.
- **Reasoning Panel:** Chat-like history of "Model Thoughts".
- **Controls:** If Live -> "Drop Piece" buttons. If Replay -> Timeline Slider.

**Tournament Dashboard:**
- **Live Grid:** Thumbnails of active background games.
- **Leaderboard:** Table showing Rank, Model, ELO, Win Rate, Total Tokens.
- **Analytics:** Line chart of ELO history over time.

**New Game:**
- Dropdowns to select Player 1 and Player 2 (Human or Specific Model).

---

## 8. Development Roadmap

**Phase 1: Core Engine (Done)**
- Game Logic, AI Integration, CLI Test.

**Phase 2: Backend & DB (Done/Ready)**
- FastAPI setup, Postgres Schema (Games + ELO), WebSocket Manager.

**Phase 3: Frontend (Next)**
- React App, Game Board, Replay Logic, Dashboard UI.

**Phase 4: Automation**
- Tournament Script implementation and deployment.
--- End of File: TECHNICAL_SPEC.md ---

--- File: docker-compose.yml ---
services:
  # --- PostgreSQL Database ---
  db:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: connect4_arena
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d connect4_arena"]
      interval: 5s
      timeout: 5s
      retries: 5

  # --- FastAPI Backend ---
  backend:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      # Internal Docker Network URL for DB  
      - DATABASE_URL=postgresql+asyncpg://user:password@db:5432/connect4_arena
      # Forward API Keys from host .env
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - GOOGLE_API_KEY=${GOOGLE_API_KEY}
      - DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
    depends_on:
      db:
        condition: service_healthy
    volumes:
      # HOT RELOAD: Map local folder to container
      - ./backend:/app/backend

  # --- React Frontend ---
  frontend:
    build: 
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "5173:5173"
    environment:
      - CHOKIDAR_USEPOLLING=true
    depends_on:
      - backend
    volumes:
      # HOT RELOAD: Map local folder to container
      - ./frontend:/app
      # PREVENT OVERWRITE: Keep container's node_modules isolated
      - /app/node_modules

volumes:
  postgres_data:
--- End of File: docker-compose.yml ---

--- VERSION 14 END ---
